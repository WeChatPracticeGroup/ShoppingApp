{"version":3,"sources":["MemoryFileSystem.js","normalize.js","join.js","MemoryFileSystemError.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst normalize = require(\"./normalize\");\nconst join = require(\"./join\");\nconst MemoryFileSystemError = require(\"./MemoryFileSystemError\");\nconst errors = require(\"errno\");\nconst stream = require(\"readable-stream\");\n\nconst ReadableStream = stream.Readable;\nconst WritableStream = stream.Writable;\n\nfunction isDir(item) {\n\tif(typeof item !== \"object\") return false;\n\treturn item[\"\"] === true;\n}\n\nfunction isFile(item) {\n\tif(typeof item !== \"object\") return false;\n\treturn !item[\"\"];\n}\n\nfunction pathToArray(path) {\n\tpath = normalize(path);\n\tconst nix = /^\\//.test(path);\n\tif(!nix) {\n\t\tif(!/^[A-Za-z]:/.test(path)) {\n\t\t\tthrow new MemoryFileSystemError(errors.code.EINVAL, path);\n\t\t}\n\t\tpath = path.replace(/[\\\\\\/]+/g, \"\\\\\"); // multi slashs\n\t\tpath = path.split(/[\\\\\\/]/);\n\t\tpath[0] = path[0].toUpperCase();\n\t} else {\n\t\tpath = path.replace(/\\/+/g, \"/\"); // multi slashs\n\t\tpath = path.substr(1).split(\"/\");\n\t}\n\tif(!path[path.length-1]) path.pop();\n\treturn path;\n}\n\nfunction trueFn() { return true; }\nfunction falseFn() { return false; }\n\nclass MemoryFileSystem {\n\tconstructor(data) {\n\t\tthis.data = data || {};\n\t\tthis.join = join;\n\t\tthis.pathToArray = pathToArray;\n\t\tthis.normalize = normalize;\n\t}\n\n\tmeta(_path) {\n\t\tconst path = pathToArray(_path);\n\t\tlet current = this.data;\n\t\tlet i = 0;\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\treturn;\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\treturn current[path[i]];\n\t}\n\n\texistsSync(_path) {\n\t\treturn !!this.meta(_path);\n\t}\n\n\tstatSync(_path) {\n\t\tlet current = this.meta(_path);\n\t\tif(_path === \"/\" || isDir(current)) {\n\t\t\treturn {\n\t\t\t\tisFile: falseFn,\n\t\t\t\tisDirectory: trueFn,\n\t\t\t\tisBlockDevice: falseFn,\n\t\t\t\tisCharacterDevice: falseFn,\n\t\t\t\tisSymbolicLink: falseFn,\n\t\t\t\tisFIFO: falseFn,\n\t\t\t\tisSocket: falseFn\n\t\t\t};\n\t\t} else if(isFile(current)) {\n\t\t\treturn {\n\t\t\t\tisFile: trueFn,\n\t\t\t\tisDirectory: falseFn,\n\t\t\t\tisBlockDevice: falseFn,\n\t\t\t\tisCharacterDevice: falseFn,\n\t\t\t\tisSymbolicLink: falseFn,\n\t\t\t\tisFIFO: falseFn,\n\t\t\t\tisSocket: falseFn\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"stat\");\n\t\t}\n\t}\n\n\treadFileSync(_path, optionsOrEncoding) {\n\t\tconst path = pathToArray(_path);\n\t\tlet current = this.data;\n\t\tlet i = 0\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"readFile\");\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\tif(!isFile(current[path[i]])) {\n\t\t\tif(isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.EISDIR, _path, \"readFile\");\n\t\t\telse\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"readFile\");\n\t\t}\n\t\tcurrent = current[path[i]];\n\t\tconst encoding = typeof optionsOrEncoding === \"object\" ? optionsOrEncoding.encoding : optionsOrEncoding;\n\t\treturn encoding ? current.toString(encoding) : current;\n\t}\n\n\treaddirSync(_path) {\n\t\tif(_path === \"/\") return Object.keys(this.data).filter(Boolean);\n\t\tconst path = pathToArray(_path);\n\t\tlet current = this.data;\n\t\tlet i = 0;\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"readdir\");\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\tif(!isDir(current[path[i]])) {\n\t\t\tif(isFile(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOTDIR, _path, \"readdir\");\n\t\t\telse\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"readdir\");\n\t\t}\n\t\treturn Object.keys(current[path[i]]).filter(Boolean);\n\t}\n\n\tmkdirpSync(_path) {\n\t\tconst path = pathToArray(_path);\n\t\tif(path.length === 0) return;\n\t\tlet current = this.data;\n\t\tfor(let i = 0; i < path.length; i++) {\n\t\t\tif(isFile(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOTDIR, _path, \"mkdirp\");\n\t\t\telse if(!isDir(current[path[i]]))\n\t\t\t\tcurrent[path[i]] = {\"\":true};\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\treturn;\n\t}\n\n\tmkdirSync(_path) {\n\t\tconst path = pathToArray(_path);\n\t\tif(path.length === 0) return;\n\t\tlet current = this.data;\n\t\tlet i = 0;\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"mkdir\");\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\tif(isDir(current[path[i]]))\n\t\t\tthrow new MemoryFileSystemError(errors.code.EEXIST, _path, \"mkdir\");\n\t\telse if(isFile(current[path[i]]))\n\t\t\tthrow new MemoryFileSystemError(errors.code.ENOTDIR, _path, \"mkdir\");\n\t\tcurrent[path[i]] = {\"\":true};\n\t\treturn;\n\t}\n\n\t_remove(_path, name, testFn) {\n\t\tconst path = pathToArray(_path);\n\t\tconst operation = name === \"File\" ? \"unlink\" : \"rmdir\";\n\t\tif(path.length === 0) {\n\t\t\tthrow new MemoryFileSystemError(errors.code.EPERM, _path, operation);\n\t\t}\n\t\tlet current = this.data;\n\t\tlet i = 0;\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, operation);\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\tif(!testFn(current[path[i]]))\n\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, operation);\n\t\tdelete current[path[i]];\n\t\treturn;\n\t}\n\n\trmdirSync(_path) {\n\t\treturn this._remove(_path, \"Directory\", isDir);\n\t}\n\n\tunlinkSync(_path) {\n\t\treturn this._remove(_path, \"File\", isFile);\n\t}\n\n\treadlinkSync(_path) {\n\t\tthrow new MemoryFileSystemError(errors.code.ENOSYS, _path, \"readlink\");\n\t}\n\n\twriteFileSync(_path, content, optionsOrEncoding) {\n\t\tif(!content && !optionsOrEncoding) throw new Error(\"No content\");\n\t\tconst path = pathToArray(_path);\n\t\tif(path.length === 0) {\n\t\t\tthrow new MemoryFileSystemError(errors.code.EISDIR, _path, \"writeFile\");\n\t\t}\n\t\tlet current = this.data;\n\t\tlet i = 0\n\t\tfor(; i < path.length - 1; i++) {\n\t\t\tif(!isDir(current[path[i]]))\n\t\t\t\tthrow new MemoryFileSystemError(errors.code.ENOENT, _path, \"writeFile\");\n\t\t\tcurrent = current[path[i]];\n\t\t}\n\t\tif(isDir(current[path[i]]))\n\t\t\tthrow new MemoryFileSystemError(errors.code.EISDIR, _path, \"writeFile\");\n\t\tconst encoding = typeof optionsOrEncoding === \"object\" ? optionsOrEncoding.encoding : optionsOrEncoding;\n\t\tcurrent[path[i]] = optionsOrEncoding || typeof content === \"string\" ? new Buffer(content, encoding) : content;\n\t\treturn;\n\t}\n\n\t// stream methods\n\tcreateReadStream(path, options) {\n\t\tlet stream = new ReadableStream();\n\t\tlet done = false;\n\t\tlet data;\n\t\ttry {\n\t\t\tdata = this.readFileSync(path);\n\t\t} catch (e) {\n\t\t\tstream._read = function() {\n\t\t\t\tif (done) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t\tthis.emit('error', e);\n\t\t\t\tthis.push(null);\n\t\t\t};\n\t\t\treturn stream;\n\t\t}\n\t\toptions = options || { };\n\t\toptions.start = options.start || 0;\n\t\toptions.end = options.end || data.length;\n\t\tstream._read = function() {\n\t\t\tif (done) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdone = true;\n\t\t\tthis.push(data.slice(options.start, options.end));\n\t\t\tthis.push(null);\n\t\t};\n\t\treturn stream;\n\t}\n\n\tcreateWriteStream(path) {\n\t\tlet stream = new WritableStream();\n\t\ttry {\n\t\t\t// Zero the file and make sure it is writable\n\t\t\tthis.writeFileSync(path, new Buffer(0));\n\t\t} catch(e) {\n\t\t\t// This or setImmediate?\n\t\t\tstream.once('prefinish', function() {\n\t\t\t\tstream.emit('error', e);\n\t\t\t});\n\t\t\treturn stream;\n\t\t}\n\t\tlet bl = [ ], len = 0;\n\t\tstream._write = (chunk, encoding, callback) => {\n\t\t\tbl.push(chunk);\n\t\t\tlen += chunk.length;\n\t\t\tthis.writeFile(path, Buffer.concat(bl, len), callback);\n\t\t}\n\t\treturn stream;\n\t}\n\n\t// async functions\n\texists(path, callback) {\n\t\treturn callback(this.existsSync(path));\n\t}\n\n\twriteFile(path, content, encoding, callback) {\n\t\tif(!callback) {\n\t\t\tcallback = encoding;\n\t\t\tencoding = undefined;\n\t\t}\n\t\ttry {\n\t\t\tthis.writeFileSync(path, content, encoding);\n\t\t} catch(e) {\n\t\t\treturn callback(e);\n\t\t}\n\t\treturn callback();\n\t}\n}\n\n// async functions\n\n[\"stat\", \"readdir\", \"mkdirp\", \"rmdir\", \"unlink\", \"readlink\"].forEach(function(fn) {\n\tMemoryFileSystem.prototype[fn] = function(path, callback) {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = this[fn + \"Sync\"](path);\n\t\t} catch(e) {\n\t\t\tsetImmediate(function() {\n\t\t\t\tcallback(e);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t\tsetImmediate(function() {\n\t\t\tcallback(null, result);\n\t\t});\n\t};\n});\n\n[\"mkdir\", \"readFile\"].forEach(function(fn) {\n\tMemoryFileSystem.prototype[fn] = function(path, optArg, callback) {\n\t\tif(!callback) {\n\t\t\tcallback = optArg;\n\t\t\toptArg = undefined;\n\t\t}\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = this[fn + \"Sync\"](path, optArg);\n\t\t} catch(e) {\n\t\t\tsetImmediate(function() {\n\t\t\t\tcallback(e);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t\tsetImmediate(function() {\n\t\t\tcallback(null, result);\n\t\t});\n\t};\n});\n\nmodule.exports = MemoryFileSystem;\n","\n\n// eslint-disable-next-line complexity\nmodule.exports = function normalize(path) {\n\tvar parts = path.split(/(\\\\+|\\/+)/);\n\tif(parts.length === 1)\n\t\treturn path;\n\tvar result = [];\n\tvar absolutePathStart = 0;\n\tfor(var i = 0, sep = false; i < parts.length; i += 1, sep = !sep) {\n\t\tvar part = parts[i];\n\t\tif(i === 0 && /^([A-Z]:)?$/i.test(part)) {\n\t\t\tresult.push(part);\n\t\t\tabsolutePathStart = 2;\n\t\t} else if(sep) {\n\t\t\t// UNC paths on Windows begin with a double backslash.\n\t\t\tif (i === 1 && parts[0].length === 0 && part === \"\\\\\\\\\") {\n\t\t\t\tresult.push(part);\n\t\t\t} else {\n\t\t\t\tresult.push(part[0]);\n\t\t\t}\n\t\t} else if(part === \"..\") {\n\t\t\tswitch(result.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// i. e. \"..\" => \"..\"\n\t\t\t\t\t// i. e. \"../a/b/c\" => \"../a/b/c\"\n\t\t\t\t\tresult.push(part);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// i. e. \"a/..\" => \"\"\n\t\t\t\t\t// i. e. \"/..\" => \"/\"\n\t\t\t\t\t// i. e. \"C:\\..\" => \"C:\\\"\n\t\t\t\t\t// i. e. \"a/../b/c\" => \"b/c\"\n\t\t\t\t\t// i. e. \"/../b/c\" => \"/b/c\"\n\t\t\t\t\t// i. e. \"C:\\..\\a\\b\\c\" => \"C:\\a\\b\\c\"\n\t\t\t\t\tif (result[0] !== \".\") {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tsep = !sep;\n\t\t\t\t\t\tresult.length = absolutePathStart;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.length = 0;\n\t\t\t\t\t\tresult.push(part);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t// i. e. \"a/b/..\" => \"a\"\n\t\t\t\t\t// i. e. \"/a/..\" => \"/\"\n\t\t\t\t\t// i. e. \"C:\\a\\..\" => \"C:\\\"\n\t\t\t\t\t// i. e. \"/a/../b/c\" => \"/b/c\"\n\t\t\t\t\tif(absolutePathStart === 0) {\n\t\t\t\t\t\tresult.length -= 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tsep = !sep;\n\t\t\t\t\t\tresult.length = 2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// i. e. \"/a/b/..\" => \"/a\"\n\t\t\t\t\t// i. e. \"/a/b/../c\" => \"/a/c\"\n\t\t\t\t\tresult.length -= 3;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if(part === \".\") {\n\t\t\tswitch(result.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// i. e. \".\" => \".\"\n\t\t\t\t\t// i. e. \"./a/b/c\" => \"./a/b/c\"\n\t\t\t\t\tresult.push(part);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// i. e. \"a/.\" => \"a\"\n\t\t\t\t\t// i. e. \"/.\" => \"/\"\n\t\t\t\t\t// i. e. \"C:\\.\" => \"C:\\\"\n\t\t\t\t\t// i. e. \"C:\\.\\a\\b\\c\" => \"C:\\a\\b\\c\"\n\t\t\t\t\tif(absolutePathStart === 0) {\n\t\t\t\t\t\tresult.length -= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tsep = !sep;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// i. e. \"a/b/.\" => \"a/b\"\n\t\t\t\t\t// i. e. \"/a/.\" => \"/\"\n\t\t\t\t\t// i. e. \"C:\\a\\.\" => \"C:\\\"\n\t\t\t\t\t// i. e. \"a/./b/c\" => \"a/b/c\"\n\t\t\t\t\t// i. e. \"/a/./b/c\" => \"/a/b/c\"\n\t\t\t\t\tresult.length -= 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if(part) {\n\t\t\tresult.push(part);\n\t\t}\n\t}\n\tif(result.length === 1 && /^[A-Za-z]:$/.test(result[0]))\n\t\treturn result[0] + \"\\\\\";\n\treturn result.join(\"\");\n};\n","\n\nconst normalize = require(\"./normalize\");\n\nconst absoluteWinRegExp = /^[A-Z]:([\\\\\\/]|$)/i;\nconst absoluteNixRegExp = /^\\//i;\n\nmodule.exports = function join(path, request) {\n\tif(!request) return normalize(path);\n\tif(absoluteWinRegExp.test(request)) return normalize(request.replace(/\\//g, \"\\\\\"));\n\tif(absoluteNixRegExp.test(request)) return normalize(request);\n\tif(path == \"/\") return normalize(path + request);\n\tif(absoluteWinRegExp.test(path)) return normalize(path.replace(/\\//g, \"\\\\\") + \"\\\\\" + request.replace(/\\//g, \"\\\\\"));\n\tif(absoluteNixRegExp.test(path)) return normalize(path + \"/\" + request);\n\treturn normalize(path + \"/\" + request);\n};\n","\n\n\nclass MemoryFileSystemError extends Error {\n\tconstructor(err, path, operation) {\n\t\tsuper(err, path);\n\n\t\t// Set `name` and `message` before call `Error.captureStackTrace` \\\n\t\t// so that we will obtain the correct 1st line of stack, like:\n\t\t// [Error]: [Message]\n\t\tthis.name = this.constructor.name;\n\t\tvar message = [`${err.code}:`, `${err.description},`];\n\t\t// Add operation name and path into message, similar to node `fs` style.\n\t\tif(operation) {\n\t\t\tmessage.push(operation);\n\t\t}\n\t\tmessage.push(`\\'${path}\\'`);\n\t\tthis.message = message.join(' ');\n\n\t\tthis.code = err.code;\n\t\tthis.errno = err.errno;\n\t\tthis.path = path;\n\t\tthis.operation = operation;\n\n\t\tif(Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t}\n}\n\nmodule.exports = MemoryFileSystemError;\n"]}