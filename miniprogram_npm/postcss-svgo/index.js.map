{"version":3,"sources":["index.js","lib/url.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\nconst { optimize } = require('svgo');\nconst { encode, decode } = require('./lib/url');\n\nconst PLUGIN = 'postcss-svgo';\nconst dataURI = /data:image\\/svg\\+xml(;((charset=)?utf-8|base64))?,/i;\nconst dataURIBase64 = /data:image\\/svg\\+xml;base64,/i;\n\n// the following regex will globally match:\n// \\b([\\w-]+)       --> a word (a sequence of one or more [alphanumeric|underscore|dash] characters; followed by\n// \\s*=\\s*          --> an equal sign character (=) between optional whitespaces; followed by\n// \\\\\"([\\S\\s]+?)\\\\\" --> any characters (including whitespaces and newlines) between literal escaped quotes (\\\")\nconst escapedQuotes = /\\b([\\w-]+)\\s*=\\s*\\\\\"([\\S\\s]+?)\\\\\"/g;\n\n/**\n * @param {string} input the SVG string\n * @param {Options} opts\n * @return {{result: string, isUriEncoded: boolean}} the minification result\n */\nfunction minifySVG(input, opts) {\n  let svg = input;\n  let decodedUri, isUriEncoded;\n  try {\n    decodedUri = decode(input);\n    isUriEncoded = decodedUri !== input;\n  } catch (e) {\n    // Swallow exception if we cannot decode the value\n    isUriEncoded = false;\n  }\n\n  if (isUriEncoded) {\n    svg = /** @type {string} */ (decodedUri);\n  }\n\n  if (opts.encode !== undefined) {\n    isUriEncoded = opts.encode;\n  }\n\n  // normalize all escaped quote characters from svg attributes\n  // from <svg attr=\\\"value\\\"... /> to <svg attr=\"value\"... />\n  // see: https://github.com/cssnano/cssnano/issues/1194\n  svg = svg.replace(escapedQuotes, '$1=\"$2\"');\n\n  const result = optimize(svg, opts);\n  if (result.error) {\n    throw new Error(result.error);\n  }\n\n  return {\n    result: /** @type {import('svgo').OptimizedSvg}*/ (result).data,\n    isUriEncoded,\n  };\n}\n\n/**\n * @param {import('postcss').Declaration} decl\n * @param {Options} opts\n * @param {import('postcss').Result} postcssResult\n * @return {void}\n */\nfunction minify(decl, opts, postcssResult) {\n  const parsed = valueParser(decl.value);\n\n  const minified = parsed.walk((node) => {\n    if (\n      node.type !== 'function' ||\n      node.value.toLowerCase() !== 'url' ||\n      !node.nodes.length\n    ) {\n      return;\n    }\n    let { value, quote } = /** @type {valueParser.StringNode} */ (\n      node.nodes[0]\n    );\n\n    let optimizedValue;\n\n    try {\n      if (dataURIBase64.test(value)) {\n        const url = new URL(value);\n        const base64String = `${url.protocol}${url.pathname}`.replace(\n          dataURI,\n          ''\n        );\n        const svg = Buffer.from(base64String, 'base64').toString('utf8');\n        const { result } = minifySVG(svg, opts);\n        const data = Buffer.from(result).toString('base64');\n        optimizedValue = 'data:image/svg+xml;base64,' + data + url.hash;\n      } else if (dataURI.test(value)) {\n        const svg = value.replace(dataURI, '');\n        const { result, isUriEncoded } = minifySVG(svg, opts);\n        let data = isUriEncoded ? encode(result) : result;\n        // Should always encode # otherwise we yield a broken SVG\n        // in Firefox (works in Chrome however). See this issue:\n        // https://github.com/cssnano/cssnano/issues/245\n        data = data.replace(/#/g, '%23');\n        optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;\n        quote = isUriEncoded ? '\"' : \"'\";\n      } else {\n        return;\n      }\n    } catch (error) {\n      decl.warn(postcssResult, `${error}`);\n      return;\n    }\n    node.nodes[0] = Object.assign({}, node.nodes[0], {\n      value: optimizedValue,\n      quote: quote,\n      type: 'string',\n      before: '',\n      after: '',\n    });\n\n    return false;\n  });\n\n  decl.value = minified.toString();\n}\n/** @typedef {{encode?: boolean, plugins?: object[]} & import('svgo').OptimizeOptions} Options */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts = {}) {\n  return {\n    postcssPlugin: PLUGIN,\n\n    OnceExit(css, { result }) {\n      css.walkDecls((decl) => {\n        if (!dataURI.test(decl.value)) {\n          return;\n        }\n\n        minify(decl, opts, result);\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\n/**\n * @param {string} data\n * @return {string}\n */\nfunction encode(data) {\n  return data\n    .replace(/\"/g, \"'\")\n    .replace(/%/g, '%25')\n    .replace(/</g, '%3C')\n    .replace(/>/g, '%3E')\n    .replace(/&/g, '%26')\n    .replace(/#/g, '%23')\n    .replace(/\\s+/g, ' ');\n}\n\nconst decode = decodeURIComponent;\nmodule.exports = { encode, decode };\n"]}