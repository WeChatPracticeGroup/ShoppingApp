{"version":3,"sources":["index.js","lib/decl/index.js","lib/decl/borders.js","lib/insertCloned.js","lib/parseTrbl.js","lib/hasAllProps.js","lib/getDecls.js","lib/getRules.js","lib/getLastNode.js","lib/getValue.js","lib/mergeRules.js","lib/minifyTrbl.js","lib/minifyWsc.js","lib/parseWsc.js","lib/validateWsc.js","lib/colornames.js","lib/canMerge.js","lib/isCustomProp.js","lib/trbl.js","lib/canExplode.js","lib/decl/columns.js","lib/decl/margin.js","lib/decl/boxBase.js","lib/mergeValues.js","lib/decl/padding.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ACHA;AHUA,AENA,ACHA,ACHA;AJaA,AENA,ACHA,ACHA;AJaA,AENA,ACHA,ACHA;AJaA,AENA,AGTA,AFMA,ACHA;AJaA,AENA,AGTA,AFMA,ACHA;AJaA,AENA,AGTA,AFMA,ACHA;AJaA,AENA,AIZA,ADGA,AFMA,ACHA;AJaA,AENA,AIZA,ADGA,AFMA,ACHA;AJaA,AENA,AIZA,ADGA,AFMA,ACHA;AJaA,AENA,AIZA,ACHA,AFMA,AFMA,ACHA;AJaA,AENA,AIZA,ACHA,AFMA,AFMA,ACHA;AJaA,AENA,AIZA,ACHA,AJYA,ACHA;AFOA,AIZA,AENA,ADGA,AHSA;AFOA,AIZA,AENA,ADGA;ALgBA,AIZA,AENA,ADGA;ALgBA,AIZA,AENA,ADGA,AENA;APsBA,AIZA,AENA,ADGA,AENA;APsBA,AIZA,AENA,ADGA,AENA;APsBA,AIZA,AENA,ADGA,AENA,ACHA;ARyBA,AIZA,AENA,ADGA,AENA,ACHA;ARyBA,AIZA,ACHA,AENA,ACHA;ARyBA,AKfA,AENA,ACHA,ACHA;AT4BA,AKfA,AENA,ACHA,ACHA;AT4BA,AKfA,AENA,ACHA,ACHA;AT4BA,AKfA,AGTA,ACHA,ACHA;AV+BA,AQxBA,ACHA,ACHA;AV+BA,AQxBA,ACHA,ACHA;AV+BA,AQxBA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AZqCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AZqCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,Ae7CA,APqBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,Ae7CA,APqBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,Ae7CA,APqBA,ACHA,ACHA,ACHA,ACHA;AELA,ADGA,AbuCA,Ae7CA,APqBA,ACHA,ACHA,ACHA,AKfA,AJYA;AELA,ADGA,AbuCA,AQxBA,AENA,ACHA,AKfA,AJYA;AELA,ADGA,AbuCA,AQxBA,AENA,ACHA,AKfA,AJYA;AKdA,AHSA,ADGA,AbuCA,AQxBA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AQxBA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AQxBA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,AV8BA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,AV8BA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,AV8BA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AkBtDA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AavCA,AV8BA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AavCA,AV8BA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AavCA,AV8BA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AHSA,ADGA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AELA,ADGA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,APqBA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA,ANkBA;ACFA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AoB5DA,AFMA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;ALgBA,AbuCA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst processors = require('./lib/decl');\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-longhand',\n\n    OnceExit(css) {\n      css.walkRules((rule) => {\n        processors.forEach((p) => {\n          p.explode(rule);\n          p.merge(rule);\n        });\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst borders = require('./borders');\nconst columns = require('./columns');\nconst margin = require('./margin');\nconst padding = require('./padding');\n\nmodule.exports = [borders, columns, margin, padding];\n","\nconst { list } = require('postcss');\nconst stylehacks = require('stylehacks');\nconst insertCloned = require('../insertCloned.js');\nconst parseTrbl = require('../parseTrbl.js');\nconst hasAllProps = require('../hasAllProps.js');\nconst getDecls = require('../getDecls.js');\nconst getRules = require('../getRules.js');\nconst getValue = require('../getValue.js');\nconst mergeRules = require('../mergeRules.js');\nconst minifyTrbl = require('../minifyTrbl.js');\nconst minifyWsc = require('../minifyWsc.js');\nconst canMerge = require('../canMerge.js');\nconst trbl = require('../trbl.js');\nconst isCustomProp = require('../isCustomProp.js');\nconst canExplode = require('../canExplode.js');\nconst getLastNode = require('../getLastNode.js');\nconst parseWsc = require('../parseWsc.js');\nconst { isValidWsc } = require('../validateWsc.js');\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\nconst colorMightRequireFallback =\n  /(hsla|rgba|color|hwb|lab|lch|oklab|oklch)\\(/i;\n\n/**\n * @param {...string} parts\n * @return {string}\n */\nfunction borderProperty(...parts) {\n  return `border-${parts.join('-')}`;\n}\n/**\n * @param {string} value\n * @return {string}\n */\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = trbl.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\n/** @type {string[]} */\nconst directionalProperties = directions.reduce(\n  (prev, curr) => prev.concat(wsc.map((prop) => `${curr}-${prop}`)),\n  /** @type {string[]} */ ([])\n);\n\nconst precedence = [\n  ['border'],\n  directions.concat(properties),\n  directionalProperties,\n];\n\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\n/**\n * @param {string} prop\n * @return {number | undefined}\n */\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (precedence[i].includes(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n\n/** @type {(value: string) => boolean} */\nconst isValueCustomProp = (value) =>\n  value !== undefined && value.search(/var\\s*\\(\\s*--/i) !== -1;\n\n/**\n * @param {string[]} values\n * @return {boolean}\n */\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp);\n}\n\n/**\n * @param {import('postcss').Declaration} decl\n * @return {string}\n */\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return parseWsc(decl.value)[2] || defaults[2];\n}\n\n/**\n * @param {[string, string, string]} values\n * @param {[string, string, string]} nextValues\n * @return {string[]}\n */\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  }, /** @type {string[]} */ ([]));\n}\n\n/**\n * @param {{values: [string, string, string], nextValues: [string, string, string], decl: import('postcss').Declaration, nextDecl: import('postcss').Declaration, index: number}} arg\n * @return {void}\n */\nfunction mergeRedundant({ values, nextValues, decl, nextDecl, index }) {\n  if (!canMerge([decl, nextDecl])) {\n    return;\n  }\n\n  if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length !== 1) {\n    return;\n  }\n\n  const prop = /** @type {string} */ (diff.pop());\n  const position = wsc.indexOf(prop);\n\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n\n  let props = parseTrbl(values[position]);\n\n  props[index] = nextValues[position];\n\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = minifyTrbl(props);\n\n  const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value)\n    .length;\n  const newLength1 =\n    decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n\n/**\n * @param {string | string[]} mapped\n * @return {boolean}\n */\nfunction isCloseEnough(mapped) {\n  return (\n    (mapped[0] === mapped[1] && mapped[1] === mapped[2]) ||\n    (mapped[1] === mapped[2] && mapped[2] === mapped[3]) ||\n    (mapped[2] === mapped[3] && mapped[3] === mapped[0]) ||\n    (mapped[3] === mapped[0] && mapped[0] === mapped[1])\n  );\n}\n\n/**\n * @param {string[]} mapped\n * @return {string[]}\n */\nfunction getDistinctShorthands(mapped) {\n  return [...new Set(mapped)];\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, (decl) => {\n    if (!canExplode(decl, false)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase();\n\n    // border -> border-trbl\n    if (prop === 'border') {\n      if (isValidWsc(parseWsc(decl.value))) {\n        directions.forEach((direction) => {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            { prop: direction }\n          );\n        });\n\n        decl.remove();\n      }\n    }\n\n    // border-trbl -> border-trbl-wsc\n    if (directions.some((direction) => prop === direction)) {\n      let values = parseWsc(decl.value);\n\n      if (isValidWsc(values)) {\n        wsc.forEach((d, i) => {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            {\n              prop: `${prop}-${d}`,\n              value: values[i] || defaults[i],\n            }\n          );\n        });\n\n        decl.remove();\n      }\n    }\n\n    // border-wsc -> border-trbl-wsc\n    wsc.some((style) => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      if (isCustomProp(decl)) {\n        decl.prop = decl.prop.toLowerCase();\n        return false;\n      }\n      parseTrbl(decl.value).forEach((value, i) => {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (decl.parent),\n          decl,\n          {\n            prop: borderProperty(trbl[i], style),\n            value,\n          }\n        );\n      });\n\n      return decl.remove();\n    });\n  });\n}\n\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  trbl.forEach((direction) => {\n    const prop = borderProperty(direction);\n\n    mergeRules(\n      rule,\n      wsc.map((style) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: rules.map(getValue).join(' '),\n            }\n          );\n          for (const node of rules) {\n            node.remove();\n          }\n\n          return true;\n        }\n        return false;\n      }\n    );\n  });\n\n  // border-trbl-wsc -> border-wsc\n  wsc.forEach((style) => {\n    const prop = borderProperty(style);\n\n    mergeRules(\n      rule,\n      trbl.map((direction) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: minifyTrbl(rules.map(getValue).join(' ')),\n            }\n          );\n\n          for (const node of rules) {\n            node.remove();\n          }\n\n          return true;\n        }\n        return false;\n      }\n    );\n  });\n\n  // border-trbl -> border-wsc\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(({ value }) => value);\n\n    if (!canMergeValues(values)) {\n      return false;\n    }\n\n    const parsed = values.map((value) => parseWsc(value));\n\n    if (!parsed.every(isValidWsc)) {\n      return false;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map((v) => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode,\n          {\n            prop: borderProperty(d),\n            value: minifyTrbl(\n              /** @type {[string, string, string, string]} */ (value)\n            ),\n          }\n        );\n      } else {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode\n        );\n      }\n    });\n\n    for (const node of rules) {\n      node.remove();\n    }\n\n    return true;\n  });\n\n  // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n\n    if (!canMergeValues(mapped)) {\n      return false;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && canMerge(rules, false)) {\n      const first =\n        mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n\n      const border = insertCloned(\n        /** @type {import('postcss').Rule} */ (lastNode.parent),\n        lastNode,\n        {\n          prop: 'border',\n          value: first ? reduced[0] : reduced[1],\n        }\n      );\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(trbl[mapped.indexOf(value)]);\n\n        rule.insertAfter(\n          border,\n          Object.assign(lastNode.clone(), {\n            prop,\n            value,\n          })\n        );\n      }\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(\n        color,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: [width, style].map(getValue).join(' '),\n        })\n      );\n      rules\n        .filter((node) => node.prop.toLowerCase() !== properties[2])\n        .forEach((node) => node.remove());\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-wsc -> border + border-trbl\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter((p) => p !== none);\n      const mostCommon = reduced.sort(\n        (a, b) =>\n          mapped.filter((v) => v === b).length -\n          mapped.filter((v) => v === a).length\n      )[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: borderValue,\n        })\n      );\n\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(\n            lastNode,\n            Object.assign(lastNode.clone(), {\n              prop: dir,\n              value: mapped[i],\n            })\n          );\n        }\n      });\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-trbl -> border\n  // border-trbl -> border + border-trbl\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => {\n      const wscValue = parseWsc(node.value);\n\n      if (!isValidWsc(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first =\n        values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: minifyWsc(first ? values[0] : values[1]),\n        })\n      );\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(\n          lastNode,\n          Object.assign(lastNode.clone(), {\n            prop: prop,\n            value: minifyWsc(value),\n          })\n        );\n      }\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n  directions.forEach((direction) => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n\n      mergeRules(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return false;\n        }\n\n        const values = parseWsc(lastNode.value);\n\n        if (!isValidWsc(values)) {\n          return false;\n        }\n\n        const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n          return false;\n        }\n\n        const wscValue = values[i];\n\n        values[i] = wscProp.value;\n\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: wscValue,\n            }\n          );\n          lastNode.value = minifyWsc(/** @type {any} */ (values));\n\n          wscProp.remove();\n\n          return true;\n        }\n        return false;\n      });\n    });\n  });\n\n  // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    mergeRules(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return false;\n      }\n\n      const values = parseWsc(lastNode.value);\n\n      if (!isValidWsc(values)) {\n        return false;\n      }\n\n      const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n        return false;\n      }\n\n      const wscValue = values[i];\n\n      values[i] = wscProp.value;\n\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode,\n          {\n            prop,\n            value: wscValue,\n          }\n        );\n        lastNode.value = minifyWsc(/** @type {any} */ (values));\n        wscProp.remove();\n\n        return true;\n      }\n      return false;\n    });\n  });\n\n  // optimize border-trbl\n  let decls = getDecls(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n\n    wsc.forEach((d, i) => {\n      const names = directions\n        .filter((name) => name !== lastNode.prop)\n        .map((name) => `${name}-${d}`);\n\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n\n      const border = getLastNode(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(\n        (node) =>\n          node.type === 'decl' &&\n          names.includes(node.prop) &&\n          node.important === lastNode.important\n      );\n      const rules = getRules(\n        /** @type {import('postcss').Declaration[]} */ (props),\n        names\n      );\n\n      if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {\n        const values = rules.map((node) => (node ? node.value : null));\n        const filteredValues = values.filter(Boolean);\n        const lastNodeValue = list.space(lastNode.value)[i];\n\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n\n        let value = minifyTrbl(values.join(' '));\n\n        if (\n          filteredValues[0] === filteredValues[1] &&\n          filteredValues[1] === filteredValues[2]\n        ) {\n          value = /** @type {string} */ (filteredValues[0]);\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n          let valueArray = list.space(lastNode.value);\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (refNode.parent),\n          /** @type {import('postcss').Declaration} */ (refNode),\n          {\n            prop: borderProperty(d),\n            value,\n          }\n        );\n\n        decls = decls.filter((node) => !rules.includes(node));\n        for (const node of rules) {\n          node.remove();\n        }\n      }\n    });\n\n    decls = decls.filter((node) => node !== lastNode);\n  }\n\n  rule.walkDecls('border', (decl) => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return false;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (index === -1) {\n      return;\n    }\n\n    const values = parseWsc(decl.value);\n    const nextValues = parseWsc(nextDecl.value);\n\n    if (!isValidWsc(values) || !isValidWsc(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index,\n    };\n\n    return mergeRedundant(config);\n  });\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    let values = parseWsc(decl.value);\n\n    if (!isValidWsc(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map((dir) => `${dir}-${d}`);\n\n      mergeRules(rule, [decl.prop, ...props], (rules) => {\n        if (!rules.includes(decl)) {\n          return false;\n        }\n\n        const longhands = rules.filter((p) => p !== decl);\n\n        if (\n          longhands[0].value.toLowerCase() ===\n            longhands[1].value.toLowerCase() &&\n          longhands[1].value.toLowerCase() ===\n            longhands[2].value.toLowerCase() &&\n          values[i] !== undefined &&\n          longhands[0].value.toLowerCase() === values[i].toLowerCase()\n        ) {\n          for (const node of longhands) {\n            node.remove();\n          }\n\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            {\n              prop: borderProperty(d),\n              value: values[i],\n            }\n          );\n\n          /** @type {string|null} */ (values[i]) = null;\n        }\n        return false;\n      });\n\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  });\n\n  // clean-up values\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    decl.value = minifyWsc(decl.value);\n  });\n\n  // border-spacing-hv -> border-spacing\n  rule.walkDecls(/^border-spacing$/i, (decl) => {\n    const value = list.space(decl.value);\n\n    // merge vertical and horizontal dups\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  });\n\n  // clean-up rules\n  decls = getDecls(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop();\n\n    // remove properties of lower precedence\n    const lesser = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        !isCustomProp(lastNode) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        /** @type {number} */ (getLevel(node.prop)) >\n          /** @type {number} */ (getLevel(lastNode.prop)) &&\n        (node.prop.toLowerCase().includes(lastNode.prop) ||\n          node.prop.toLowerCase().endsWith(/** @type {string} */ (lastPart)))\n    );\n\n    for (const node of lesser) {\n      node.remove();\n    }\n    decls = decls.filter((node) => !lesser.includes(node));\n\n    // get duplicate properties\n    let duplicates = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        node.prop === lastNode.prop &&\n        !(!isCustomProp(node) && isCustomProp(lastNode))\n    );\n\n    if (duplicates.length) {\n      if (colorMightRequireFallback.test(getColorValue(lastNode))) {\n        const preserve = duplicates\n          .filter(\n            (node) => !colorMightRequireFallback.test(getColorValue(node))\n          )\n          .pop();\n\n        duplicates = duplicates.filter((node) => node !== preserve);\n      }\n      for (const node of duplicates) {\n        node.remove();\n      }\n    }\n\n    decls = decls.filter(\n      (node) => node !== lastNode && !duplicates.includes(node)\n    );\n  }\n}\n\nmodule.exports = {\n  explode,\n  merge,\n};\n","\n/**\n * @param {import('postcss').Rule} rule\n * @param {import('postcss').Declaration} decl\n * @param {Partial<import('postcss').DeclarationProps>=} props\n * @return {import('postcss').Declaration}\n */\nmodule.exports = function insertCloned(rule, decl, props) {\n  const newNode = Object.assign(decl.clone(), props);\n\n  rule.insertAfter(decl, newNode);\n\n  return newNode;\n};\n","\nconst { list } = require('postcss');\n/** @type {(v: string | string[]) => [string, string, string, string]} */\nmodule.exports = (v) => {\n  const s = typeof v === 'string' ? list.space(v) : v;\n  return [\n    s[0], // top\n    s[1] || s[0], // right\n    s[2] || s[0], // bottom\n    s[3] || s[1] || s[0], // left\n  ];\n};\n","\n/** @type {(rule: import('postcss').Declaration[], ...props: string[]) => boolean} */\nmodule.exports = (rule, ...props) => {\n  return props.every((p) =>\n    rule.some((node) => node.prop && node.prop.toLowerCase().includes(p))\n  );\n};\n","\n/**\n * @param {import('postcss').Rule} rule\n * @param {string[]} properties\n * @return {import('postcss').Declaration[]}\n */\nmodule.exports = function getDecls(rule, properties) {\n  return /** @type {import('postcss').Declaration[]} */ (\n    rule.nodes.filter(\n      (node) =>\n        node.type === 'decl' && properties.includes(node.prop.toLowerCase())\n    )\n  );\n};\n","\nconst getLastNode = require('./getLastNode.js');\n\n/**\n * @param {import('postcss').Declaration[]} props\n * @param {string[]} properties\n * @return {import('postcss').Declaration[]}\n */\nmodule.exports = function getRules(props, properties) {\n  return properties\n    .map((property) => {\n      return getLastNode(props, property);\n    })\n    .filter(Boolean);\n};\n","\n/** @type {(rule: import('postcss').AnyNode[], prop: string) => import('postcss').Declaration} */\nmodule.exports = (rule, prop) => {\n  return /** @type {import('postcss').Declaration} */ (\n    rule.filter((n) => n.type === 'decl' && n.prop.toLowerCase() === prop).pop()\n  );\n};\n","\n/**\n * @param {import('postcss').Declaration} arg\n * @return {string}\n */\nmodule.exports = function getValue({ value }) {\n  return value;\n};\n","\nconst hasAllProps = require('./hasAllProps.js');\nconst getDecls = require('./getDecls.js');\nconst getRules = require('./getRules.js');\n\n/**\n * @param {import('postcss').Declaration} propA\n * @param {import('postcss').Declaration} propB\n * @return {boolean}\n */\nfunction isConflictingProp(propA, propB) {\n  if (\n    !propB.prop ||\n    propB.important !== propA.important ||\n    propA.prop === propB.prop\n  ) {\n    return false;\n  }\n\n  const partsA = propA.prop.split('-');\n  const partsB = propB.prop.split('-');\n\n  /* Be safe: check that the first part matches. So we don't try to\n   * combine e.g. border-color and color.\n   */\n  if (partsA[0] !== partsB[0]) {\n    return false;\n  }\n\n  const partsASet = new Set(partsA);\n  return partsB.every((partB) => partsASet.has(partB));\n}\n\n/**\n * @param {import('postcss').Declaration[]} match\n * @param {import('postcss').Declaration[]} nodes\n * @return {boolean}\n */\nfunction hasConflicts(match, nodes) {\n  const firstNode = Math.min(...match.map((n) => nodes.indexOf(n)));\n  const lastNode = Math.max(...match.map((n) => nodes.indexOf(n)));\n  const between = nodes.slice(firstNode + 1, lastNode);\n\n  return match.some((a) => between.some((b) => isConflictingProp(a, b)));\n}\n\n/**\n * @param {import('postcss').Rule} rule\n * @param {string[]} properties\n * @param {(rules: import('postcss').Declaration[], last: import('postcss').Declaration, props: import('postcss').Declaration[]) => boolean} callback\n * @return {void}\n */\nmodule.exports = function mergeRules(rule, properties, callback) {\n  let decls = getDecls(rule, properties);\n\n  while (decls.length) {\n    const last = decls[decls.length - 1];\n    const props = decls.filter((node) => node.important === last.important);\n    const rules = getRules(props, properties);\n\n    if (\n      hasAllProps(rules, ...properties) &&\n      !hasConflicts(\n        rules,\n        /** @type import('postcss').Declaration[]*/ (rule.nodes)\n      )\n    ) {\n      if (callback(rules, last, props)) {\n        decls = decls.filter((node) => !rules.includes(node));\n      }\n    }\n\n    decls = decls.filter((node) => node !== last);\n  }\n};\n","\nconst parseTrbl = require('./parseTrbl.js');\n\n/** @type {(v: string | [string, string, string, string]) => string} */\nmodule.exports = (v) => {\n  const value = parseTrbl(v);\n\n  if (value[3] === value[1]) {\n    value.pop();\n\n    if (value[2] === value[0]) {\n      value.pop();\n\n      if (value[0] === value[1]) {\n        value.pop();\n      }\n    }\n  }\n\n  return value.join(' ');\n};\n","\nconst parseWsc = require('./parseWsc.js');\nconst minifyTrbl = require('./minifyTrbl.js');\nconst { isValidWsc } = require('./validateWsc.js');\n\nconst defaults = ['medium', 'none', 'currentcolor'];\n\n/** @type {(v: string) => string} */\nmodule.exports = (v) => {\n  const values = parseWsc(v);\n\n  if (!isValidWsc(values)) {\n    return minifyTrbl(v);\n  }\n\n  const value = [...values, '']\n    .reduceRight((prev, cur, i, arr) => {\n      if (\n        cur === undefined ||\n        (cur.toLowerCase() === defaults[i] &&\n          (!i || (arr[i - 1] || '').toLowerCase() !== cur.toLowerCase()))\n      ) {\n        return prev;\n      }\n\n      return cur + ' ' + prev;\n    })\n    .trim();\n\n  return minifyTrbl(value || 'none');\n};\n","\nconst { list } = require('postcss');\nconst { isWidth, isStyle, isColor } = require('./validateWsc.js');\n\nconst none = /^\\s*(none|medium)(\\s+none(\\s+(none|currentcolor))?)?\\s*$/i;\n\n/* Approximate https://drafts.csswg.org/css-values-4/#typedef-dashed-ident */\n// eslint-disable-next-line no-control-regex\nconst varRE = /--(\\w|-|[^\\x00-\\x7F])+/g;\n/** @type {(v: string) => string} */\nconst toLower = (v) => {\n  let match;\n  let lastIndex = 0;\n  let result = '';\n  varRE.lastIndex = 0;\n  while ((match = varRE.exec(v)) !== null) {\n    if (match.index > lastIndex) {\n      result += v.substring(lastIndex, match.index).toLowerCase();\n    }\n    result += match[0];\n    lastIndex = match.index + match[0].length;\n  }\n  if (lastIndex < v.length) {\n    result += v.substring(lastIndex).toLowerCase();\n  }\n  if (result === '') {\n    return v;\n  }\n  return result;\n};\n\n/**\n * @param {string} value\n * @return {[string, string, string]}\n */\nmodule.exports = function parseWsc(value) {\n  if (none.test(value)) {\n    return ['medium', 'none', 'currentcolor'];\n  }\n\n  let width, style, color;\n\n  const values = list.space(value);\n  if (\n    values.length > 1 &&\n    isStyle(values[1]) &&\n    values[0].toLowerCase() === 'none'\n  ) {\n    values.unshift();\n    width = '0';\n  }\n\n  /** @type {string[]} */\n  const unknown = [];\n\n  values.forEach((v) => {\n    if (isStyle(v)) {\n      style = toLower(v);\n    } else if (isWidth(v)) {\n      width = toLower(v);\n    } else if (isColor(v)) {\n      color = toLower(v);\n    } else {\n      unknown.push(v);\n    }\n  });\n\n  if (unknown.length) {\n    if (!width && style && color) {\n      width = unknown.pop();\n    }\n\n    if (width && !style && color) {\n      style = unknown.pop();\n    }\n\n    if (width && style && !color) {\n      color = unknown.pop();\n    }\n  }\n\n  return /** @type {[string, string, string]} */ ([width, style, color]);\n};\n","\nconst colors = require('./colornames.js');\n\nconst widths = new Set(['thin', 'medium', 'thick']);\nconst styles = new Set([\n  'none',\n  'hidden',\n  'dotted',\n  'dashed',\n  'solid',\n  'double',\n  'groove',\n  'ridge',\n  'inset',\n  'outset',\n]);\n\n/**\n * @param {string} value\n * @return {boolean}\n */\nfunction isStyle(value) {\n  return value !== undefined && styles.has(value.toLowerCase());\n}\n\n/**\n * @param {string} value\n * @return {boolean}\n */\nfunction isWidth(value) {\n  return (\n    (value && widths.has(value.toLowerCase())) ||\n    /^(\\d+(\\.\\d+)?|\\.\\d+)(\\w+)?$/.test(value)\n  );\n}\n\n/**\n * @param {string} value\n * @return {boolean}\n */\nfunction isColor(value) {\n  if (!value) {\n    return false;\n  }\n\n  value = value.toLowerCase();\n\n  if (/rgba?\\(/.test(value)) {\n    return true;\n  }\n\n  if (/hsla?\\(/.test(value)) {\n    return true;\n  }\n\n  if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {\n    return true;\n  }\n\n  if (value === 'transparent') {\n    return true;\n  }\n\n  if (value === 'currentcolor') {\n    return true;\n  }\n\n  return colors.has(value);\n}\n\n/**\n * @param {[string, string, string]} wscs\n * @return {boolean}\n */\nfunction isValidWsc(wscs) {\n  const validWidth = isWidth(wscs[0]);\n  const validStyle = isStyle(wscs[1]);\n  const validColor = isColor(wscs[2]);\n\n  return (\n    (validWidth && validStyle) ||\n    (validWidth && validColor) ||\n    (validStyle && validColor)\n  );\n}\n\nmodule.exports = { isStyle, isWidth, isColor, isValidWsc };\n","\n/* https://www.w3.org/TR/css-color-4/#named-colors */\nmodule.exports = new Set([\n  'aliceblue',\n  'antiquewhite',\n  'aqua',\n  'aquamarine',\n  'azure',\n  'beige',\n  'bisque',\n  'black',\n  'blanchedalmond',\n  'blue',\n  'blueviolet',\n  'brown',\n  'burlywood',\n  'cadetblue',\n  'chartreuse',\n  'chocolate',\n  'coral',\n  'cornflowerblue',\n  'cornsilk',\n  'crimson',\n  'cyan',\n  'darkblue',\n  'darkcyan',\n  'darkgoldenrod',\n  'darkgray',\n  'darkgreen',\n  'darkgrey',\n  'darkkhaki',\n  'darkmagenta',\n  'darkolivegreen',\n  'darkorange',\n  'darkorchid',\n  'darkred',\n  'darksalmon',\n  'darkseagreen',\n  'darkslateblue',\n  'darkslategray',\n  'darkslategrey',\n  'darkturquoise',\n  'darkviolet',\n  'deeppink',\n  'deepskyblue',\n  'dimgray',\n  'dimgrey',\n  'dodgerblue',\n  'firebrick',\n  'floralwhite',\n  'forestgreen',\n  'fuchsia',\n  'gainsboro',\n  'ghostwhite',\n  'gold',\n  'goldenrod',\n  'gray',\n  'green',\n  'greenyellow',\n  'grey',\n  'honeydew',\n  'hotpink',\n  'indianred',\n  'indigo',\n  'ivory',\n  'khaki',\n  'lavender',\n  'lavenderblush',\n  'lawngreen',\n  'lemonchiffon',\n  'lightblue',\n  'lightcoral',\n  'lightcyan',\n  'lightgoldenrodyellow',\n  'lightgray',\n  'lightgreen',\n  'lightgrey',\n  'lightpink',\n  'lightsalmon',\n  'lightseagreen',\n  'lightskyblue',\n  'lightslategray',\n  'lightslategrey',\n  'lightsteelblue',\n  'lightyellow',\n  'lime',\n  'limegreen',\n  'linen',\n  'magenta',\n  'maroon',\n  'mediumaquamarine',\n  'mediumblue',\n  'mediumorchid',\n  'mediumpurple',\n  'mediumseagreen',\n  'mediumslateblue',\n  'mediumspringgreen',\n  'mediumturquoise',\n  'mediumvioletred',\n  'midnightblue',\n  'mintcream',\n  'mistyrose',\n  'moccasin',\n  'navajowhite',\n  'navy',\n  'oldlace',\n  'olive',\n  'olivedrab',\n  'orange',\n  'orangered',\n  'orchid',\n  'palegoldenrod',\n  'palegreen',\n  'paleturquoise',\n  'palevioletred',\n  'papayawhip',\n  'peachpuff',\n  'peru',\n  'pink',\n  'plum',\n  'powderblue',\n  'purple',\n  'rebeccapurple',\n  'red',\n  'rosybrown',\n  'royalblue',\n  'saddlebrown',\n  'salmon',\n  'sandybrown',\n  'seagreen',\n  'seashell',\n  'sienna',\n  'silver',\n  'skyblue',\n  'slateblue',\n  'slategray',\n  'slategrey',\n  'snow',\n  'springgreen',\n  'steelblue',\n  'tan',\n  'teal',\n  'thistle',\n  'tomato',\n  'turquoise',\n  'violet',\n  'wheat',\n  'white',\n  'whitesmoke',\n  'yellow',\n  'yellowgreen',\n]);\n","\nconst isCustomProp = require('./isCustomProp');\n\n/** @type {(node: import('postcss').Declaration) => boolean} */\nconst important = (node) => node.important;\n/** @type {(node: import('postcss').Declaration) => boolean} */\nconst unimportant = (node) => !node.important;\n\n/* Cannot be combined with other values in shorthand \n  https://www.w3.org/TR/css-cascade-5/#shorthand */\nconst cssWideKeywords = ['inherit', 'initial', 'unset', 'revert'];\n/**\n * @type {(props: import('postcss').Declaration[], includeCustomProps?: boolean) => boolean}\n */\nmodule.exports = (props, includeCustomProps = true) => {\n  const uniqueProps = new Set(props.map((node) => node.value.toLowerCase()));\n\n  if (uniqueProps.size > 1) {\n    for (const unmergeable of cssWideKeywords) {\n      if (uniqueProps.has(unmergeable)) {\n        return false;\n      }\n    }\n  }\n\n  if (\n    includeCustomProps &&\n    props.some(isCustomProp) &&\n    !props.every(isCustomProp)\n  ) {\n    return false;\n  }\n\n  return props.every(unimportant) || props.every(important);\n};\n","\n/** @type {(node: import('postcss').Declaration) => boolean} */\nmodule.exports = (node) => node.value.search(/var\\s*\\(\\s*--/i) !== -1;\n","\nmodule.exports = ['top', 'right', 'bottom', 'left'];\n","\nconst isCustomProp = require('./isCustomProp');\n\nconst globalKeywords = new Set(['inherit', 'initial', 'unset', 'revert']);\n\n/** @type {(prop: import('postcss').Declaration, includeCustomProps?: boolean) => boolean} */\nmodule.exports = (prop, includeCustomProps = true) => {\n  if (\n    !prop.value ||\n    (includeCustomProps && isCustomProp(prop)) ||\n    (prop.value && globalKeywords.has(prop.value.toLowerCase()))\n  ) {\n    return false;\n  }\n  return true;\n};\n","\nconst { list } = require('postcss');\nconst { unit } = require('postcss-value-parser');\nconst stylehacks = require('stylehacks');\nconst canMerge = require('../canMerge.js');\nconst getDecls = require('../getDecls.js');\nconst getValue = require('../getValue.js');\nconst mergeRules = require('../mergeRules.js');\nconst insertCloned = require('../insertCloned.js');\nconst isCustomProp = require('../isCustomProp.js');\nconst canExplode = require('../canExplode.js');\n\nconst properties = ['column-width', 'column-count'];\nconst auto = 'auto';\nconst inherit = 'inherit';\n\n/**\n * Normalize a columns shorthand definition. Both of the longhand\n * properties' initial values are 'auto', and as per the spec,\n * omitted values are set to their initial values. Thus, we can\n * remove any 'auto' definition when there are two values.\n *\n * Specification link: https://www.w3.org/TR/css3-multicol/\n *\n * @param {[string, string]} values\n * @return {string}\n */\nfunction normalize(values) {\n  if (values[0].toLowerCase() === auto) {\n    return values[1];\n  }\n\n  if (values[1].toLowerCase() === auto) {\n    return values[0];\n  }\n\n  if (\n    values[0].toLowerCase() === inherit &&\n    values[1].toLowerCase() === inherit\n  ) {\n    return inherit;\n  }\n\n  return values.join(' ');\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction explode(rule) {\n  rule.walkDecls(/^columns$/i, (decl) => {\n    if (!canExplode(decl)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    let values = list.space(decl.value);\n\n    if (values.length === 1) {\n      values.push(auto);\n    }\n\n    values.forEach((value, i) => {\n      let prop = properties[1];\n      const dimension = unit(value);\n      if (value.toLowerCase() === auto) {\n        prop = properties[i];\n      } else if (dimension && dimension.unit !== '') {\n        prop = properties[0];\n      }\n\n      insertCloned(/** @type {import('postcss').Rule} */ (decl.parent), decl, {\n        prop,\n        value,\n      });\n    });\n\n    decl.remove();\n  });\n}\n\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction cleanup(rule) {\n  let decls = getDecls(rule, ['columns'].concat(properties));\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n\n    // remove properties of lower precedence\n    const lesser = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        lastNode.prop === 'columns' &&\n        node.prop !== lastNode.prop\n    );\n\n    for (const node of lesser) {\n      node.remove();\n    }\n    decls = decls.filter((node) => !lesser.includes(node));\n\n    // get duplicate properties\n    let duplicates = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        node.prop === lastNode.prop &&\n        !(!isCustomProp(node) && isCustomProp(lastNode))\n    );\n\n    for (const node of duplicates) {\n      node.remove();\n    }\n    decls = decls.filter(\n      (node) => node !== lastNode && !duplicates.includes(node)\n    );\n  }\n}\n\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction merge(rule) {\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n      insertCloned(\n        /** @type {import('postcss').Rule} */ (lastNode.parent),\n        lastNode,\n        {\n          prop: 'columns',\n          value: normalize(/** @type [string, string] */ (rules.map(getValue))),\n        }\n      );\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n    return false;\n  });\n\n  cleanup(rule);\n}\n\nmodule.exports = {\n  explode,\n  merge,\n};\n","\nconst base = require('./boxBase.js');\n\nmodule.exports = base('margin');\n","\nconst stylehacks = require('stylehacks');\nconst canMerge = require('../canMerge.js');\nconst getDecls = require('../getDecls.js');\nconst minifyTrbl = require('../minifyTrbl.js');\nconst parseTrbl = require('../parseTrbl.js');\nconst insertCloned = require('../insertCloned.js');\nconst mergeRules = require('../mergeRules.js');\nconst mergeValues = require('../mergeValues.js');\nconst trbl = require('../trbl.js');\nconst isCustomProp = require('../isCustomProp.js');\nconst canExplode = require('../canExplode.js');\n\n/**\n * @param {string} prop\n * @return {{explode: (rule: import('postcss').Rule) => void, merge: (rule: import('postcss').Rule) => void}}\n */\nmodule.exports = (prop) => {\n  const properties = trbl.map((direction) => `${prop}-${direction}`);\n  /** @type {(rule: import('postcss').Rule) => void} */\n  const cleanup = (rule) => {\n    let decls = getDecls(rule, [prop].concat(properties));\n\n    while (decls.length) {\n      const lastNode = decls[decls.length - 1];\n\n      // remove properties of lower precedence\n      const lesser = decls.filter(\n        (node) =>\n          !stylehacks.detect(lastNode) &&\n          !stylehacks.detect(node) &&\n          node !== lastNode &&\n          node.important === lastNode.important &&\n          lastNode.prop === prop &&\n          node.prop !== lastNode.prop\n      );\n\n      for (const node of lesser) {\n        node.remove();\n      }\n      decls = decls.filter((node) => !lesser.includes(node));\n\n      // get duplicate properties\n      let duplicates = decls.filter(\n        (node) =>\n          !stylehacks.detect(lastNode) &&\n          !stylehacks.detect(node) &&\n          node !== lastNode &&\n          node.important === lastNode.important &&\n          node.prop === lastNode.prop &&\n          !(!isCustomProp(node) && isCustomProp(lastNode))\n      );\n\n      for (const node of duplicates) {\n        node.remove();\n      }\n      decls = decls.filter(\n        (node) => node !== lastNode && !duplicates.includes(node)\n      );\n    }\n  };\n\n  const processor = {\n    /** @type {(rule: import('postcss').Rule) => void} */\n    explode: (rule) => {\n      rule.walkDecls(new RegExp('^' + prop + '$', 'i'), (decl) => {\n        if (!canExplode(decl)) {\n          return;\n        }\n\n        if (stylehacks.detect(decl)) {\n          return;\n        }\n\n        const values = parseTrbl(decl.value);\n\n        trbl.forEach((direction, index) => {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            {\n              prop: properties[index],\n              value: values[index],\n            }\n          );\n        });\n\n        decl.remove();\n      });\n    },\n    /** @type {(rule: import('postcss').Rule) => void} */\n    merge: (rule) => {\n      mergeRules(rule, properties, (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: minifyTrbl(mergeValues(...rules)),\n            }\n          );\n          for (const node of rules) {\n            node.remove();\n          }\n\n          return true;\n        }\n        return false;\n      });\n\n      cleanup(rule);\n    },\n  };\n\n  return processor;\n};\n","\nconst getValue = require('./getValue.js');\n\n/** @type {(...rules: import('postcss').Declaration[]) => string} */\nmodule.exports = (...rules) => rules.map(getValue).join(' ');\n","\nconst base = require('./boxBase');\n\nmodule.exports = base('padding');\n"]}