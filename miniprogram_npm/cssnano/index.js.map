{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst path = require('path');\n/** @type {any} */\nconst postcss = require('postcss');\nconst yaml = require('yaml');\nconst { lilconfigSync } = require('lilconfig');\n\nconst cssnano = 'cssnano';\n\n/** @typedef {{preset?: any, plugins?: any[], configFile?: string}} Options */\n/**\n * @param {string} moduleId\n * @returns {boolean}\n */\nfunction isResolvable(moduleId) {\n  try {\n    require.resolve(moduleId);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * preset can be one of four possibilities:\n * preset = 'default'\n * preset = ['default', {}]\n * preset = function <- to be invoked\n * preset = {plugins: []} <- already invoked function\n *\n * @param {any} preset\n * @return {[import('postcss').PluginCreator<any>, boolean | Record<string, any> | undefined][]}}\n */\nfunction resolvePreset(preset) {\n  let fn, options;\n\n  if (Array.isArray(preset)) {\n    fn = preset[0];\n    options = preset[1];\n  } else {\n    fn = preset;\n    options = {};\n  }\n\n  // For JS setups where we invoked the preset already\n  if (preset.plugins) {\n    return preset.plugins;\n  }\n\n  // Provide an alias for the default preset, as it is built-in.\n  if (fn === 'default') {\n    return require('cssnano-preset-default')(options).plugins;\n  }\n\n  // For non-JS setups; we'll need to invoke the preset ourselves.\n  if (typeof fn === 'function') {\n    return fn(options).plugins;\n  }\n\n  // Try loading a preset from node_modules\n  if (isResolvable(fn)) {\n    return require(fn)(options).plugins;\n  }\n\n  const sugar = `cssnano-preset-${fn}`;\n\n  // Try loading a preset from node_modules (sugar)\n  if (isResolvable(sugar)) {\n    return require(sugar)(options).plugins;\n  }\n\n  // If all else fails, we probably have a typo in the config somewhere\n  throw new Error(\n    `Cannot load preset \"${fn}\". Please check your configuration for errors and try again.`\n  );\n}\n\n/**\n * cssnano will look for configuration firstly as options passed\n * directly to it, and failing this it will use lilconfig to\n * load an external file.\n\n * @param {Options} options\n */\nfunction resolveConfig(options) {\n  if (options.preset) {\n    return resolvePreset(options.preset);\n  }\n\n  /** @type {string | undefined} */\n  let searchPath = process.cwd();\n  let configPath = undefined;\n\n  if (options.configFile) {\n    searchPath = undefined;\n    configPath = path.resolve(process.cwd(), options.configFile);\n  }\n\n  const configExplorer = lilconfigSync(cssnano, {\n    searchPlaces: [\n      'package.json',\n      '.cssnanorc',\n      '.cssnanorc.json',\n      '.cssnanorc.yaml',\n      '.cssnanorc.yml',\n      '.cssnanorc.js',\n      'cssnano.config.js',\n    ],\n    loaders: {\n      '.yaml': (filepath, content) => yaml.parse(content),\n      '.yml': (filepath, content) => yaml.parse(content),\n    },\n  });\n  const config = configPath\n    ? configExplorer.load(configPath)\n    : configExplorer.search(searchPath);\n\n  if (config === null) {\n    return resolvePreset('default');\n  }\n\n  return resolvePreset(config.config.preset || config.config);\n}\n\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options=} options\n * @return {import('postcss').Processor}\n */\nfunction cssnanoPlugin(options = {}) {\n  if (Array.isArray(options.plugins)) {\n    if (!options.preset || !options.preset.plugins) {\n      options.preset = { plugins: [] };\n    }\n\n    options.plugins.forEach((plugin) => {\n      if (Array.isArray(plugin)) {\n        const [pluginDef, opts = {}] = plugin;\n        if (typeof pluginDef === 'string' && isResolvable(pluginDef)) {\n          options.preset.plugins.push([require(pluginDef), opts]);\n        } else {\n          options.preset.plugins.push([pluginDef, opts]);\n        }\n      } else if (typeof plugin === 'string' && isResolvable(plugin)) {\n        options.preset.plugins.push([require(plugin), {}]);\n      } else {\n        options.preset.plugins.push([plugin, {}]);\n      }\n    });\n  }\n  const plugins = [];\n  const nanoPlugins = resolveConfig(options);\n  for (const nanoPlugin of nanoPlugins) {\n    if (Array.isArray(nanoPlugin)) {\n      const [processor, opts] = nanoPlugin;\n      if (\n        typeof opts === 'undefined' ||\n        (typeof opts === 'object' && !opts.exclude) ||\n        (typeof opts === 'boolean' && opts === true)\n      ) {\n        plugins.push(processor(opts));\n      }\n    } else {\n      plugins.push(nanoPlugin);\n    }\n  }\n  return postcss(plugins);\n}\n\ncssnanoPlugin.postcss = true;\nmodule.exports = cssnanoPlugin;\n"]}