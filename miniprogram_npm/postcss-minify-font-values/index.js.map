{"version":3,"sources":["index.js","lib/minify-weight.js","lib/minify-family.js","lib/minify-font.js","lib/keywords.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AIZA,AFMA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\nconst minifyWeight = require('./lib/minify-weight');\nconst minifyFamily = require('./lib/minify-family');\nconst minifyFont = require('./lib/minify-font');\n\n/**\n * @param {string} value\n * @return {boolean}\n */\nfunction hasVariableFunction(value) {\n  const lowerCasedValue = value.toLowerCase();\n\n  return lowerCasedValue.includes('var(') || lowerCasedValue.includes('env(');\n}\n\n/**\n * @param {string} prop\n * @param {string} value\n * @param {Options} opts\n * @return {string}\n */\nfunction transform(prop, value, opts) {\n  let lowerCasedProp = prop.toLowerCase();\n\n  if (lowerCasedProp === 'font-weight' && !hasVariableFunction(value)) {\n    return minifyWeight(value);\n  } else if (lowerCasedProp === 'font-family' && !hasVariableFunction(value)) {\n    const tree = valueParser(value);\n\n    tree.nodes = minifyFamily(tree.nodes, opts);\n\n    return tree.toString();\n  } else if (lowerCasedProp === 'font') {\n    const tree = valueParser(value);\n\n    tree.nodes = minifyFont(tree.nodes, opts);\n\n    return tree.toString();\n  }\n\n  return value;\n}\n\n/** @typedef {{removeAfterKeyword?: boolean, removeDuplicates?: boolean, removeQuotes?: boolean}} Options */\n\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts) {\n  opts = Object.assign(\n    {},\n    {\n      removeAfterKeyword: false,\n      removeDuplicates: true,\n      removeQuotes: true,\n    },\n    opts\n  );\n\n  return {\n    postcssPlugin: 'postcss-minify-font-values',\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/font/i, (decl) => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            const prop = decl.prop;\n\n            const cacheKey = `${prop}|${value}`;\n\n            if (cache.has(cacheKey)) {\n              decl.value = cache.get(cacheKey);\n\n              return;\n            }\n\n            const newValue = transform(prop, value, opts);\n\n            decl.value = newValue;\n            cache.set(cacheKey, newValue);\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\n/**\n * @param {string} value\n * @return {string}\n */\nmodule.exports = function (value) {\n  const lowerCasedValue = value.toLowerCase();\n\n  return lowerCasedValue === 'normal'\n    ? '400'\n    : lowerCasedValue === 'bold'\n    ? '700'\n    : value;\n};\n","\nconst { stringify } = require('postcss-value-parser');\n\n/**\n * @param {string[]} list\n * @return {string[]}\n */\nfunction uniqueFontFamilies(list) {\n  return list.filter((item, i) => {\n    if (item.toLowerCase() === 'monospace') {\n      return true;\n    }\n    return i === list.indexOf(item);\n  });\n}\n\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = new Set([\n  'sans-serif',\n  'serif',\n  'fantasy',\n  'cursive',\n  'monospace',\n  'system-ui',\n]);\n\n/**\n * @param {string} value\n * @param {number} length\n * @return {string[]}\n */\nfunction makeArray(value, length) {\n  let array = [];\n  while (length--) {\n    array[length] = value;\n  }\n  return array;\n}\n\n// eslint-disable-next-line no-useless-escape\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\n/**\n * @param {string} string\n * @param {boolean} escapeForString\n * @return {string}\n */\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character;\n  let charCode;\n  let value;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(0);\n\n    // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (\n      !escapeForString &&\n      regexSimpleEscapeCharacters.test(character)\n    ) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp(\n  [...genericFontFamilykeywords].concat(globalKeywords).join('|'),\n  'i'\n);\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\n/**\n * @param {string} string\n * @return {string}\n */\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  /** @type {string[] | string} */\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  });\n\n  // Escape trailing spaces unless they’re already part of an escape\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n/**\n * @param {import('postcss-value-parser').Node[]} nodes\n * @param {import('../index').Options} opts\n * @return {import('postcss-value-parser').WordNode[]}\n */\nmodule.exports = function (nodes, opts) {\n  /** @type {import('postcss-value-parser').Node[]} */\n  const family = [];\n  /** @type {import('postcss-value-parser').WordNode | null} */\n  let last = null;\n  let i, max;\n\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last = /** @type {import('postcss-value-parser').WordNode} */ ({\n          type: 'word',\n          value: '',\n        });\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n\n  let normalizedFamilies = family.map((node) => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (\n        !opts.removeQuotes ||\n        isKeyword ||\n        /[0-9]/.test(node.value.slice(0, 1))\n      ) {\n        return stringify(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return stringify(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = normalizedFamilies.length; i < max; i += 1) {\n      if (genericFontFamilykeywords.has(normalizedFamilies[i].toLowerCase())) {\n        normalizedFamilies = normalizedFamilies.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    normalizedFamilies = uniqueFontFamilies(normalizedFamilies);\n  }\n\n  return [\n    /** @type {import('postcss-value-parser').WordNode} */ ({\n      type: 'word',\n      value: normalizedFamilies.join(),\n    }),\n  ];\n};\n","\nconst { unit } = require('postcss-value-parser');\nconst keywords = require('./keywords');\nconst minifyFamily = require('./minify-family');\nconst minifyWeight = require('./minify-weight');\n\n/**\n * @param {import('postcss-value-parser').Node[]} nodes\n * @param {import('../index').Options} opts\n * @return {import('postcss-value-parser').Node[]}\n */\nmodule.exports = function (nodes, opts) {\n  let i, max, node, family;\n  let familyStart = NaN;\n  let hasSize = false;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n\n    if (node.type === 'word') {\n      if (hasSize) {\n        continue;\n      }\n\n      const value = node.value.toLowerCase();\n\n      if (\n        value === 'normal' ||\n        value === 'inherit' ||\n        value === 'initial' ||\n        value === 'unset'\n      ) {\n        familyStart = i;\n      } else if (keywords.style.has(value) || unit(value)) {\n        familyStart = i;\n      } else if (keywords.variant.has(value)) {\n        familyStart = i;\n      } else if (keywords.weight.has(value)) {\n        node.value = minifyWeight(value);\n        familyStart = i;\n      } else if (keywords.stretch.has(value)) {\n        familyStart = i;\n      } else if (keywords.size.has(value) || unit(value)) {\n        familyStart = i;\n        hasSize = true;\n      }\n    } else if (\n      node.type === 'function' &&\n      nodes[i + 1] &&\n      nodes[i + 1].type === 'space'\n    ) {\n      familyStart = i;\n    } else if (node.type === 'div' && node.value === '/') {\n      familyStart = i + 1;\n      break;\n    }\n  }\n\n  familyStart += 2;\n\n  family = minifyFamily(nodes.slice(familyStart), opts);\n\n  return nodes.slice(0, familyStart).concat(family);\n};\n","\nmodule.exports = {\n  style: new Set(['italic', 'oblique']),\n  variant: new Set(['small-caps']),\n  weight: new Set([\n    '100',\n    '200',\n    '300',\n    '400',\n    '500',\n    '600',\n    '700',\n    '800',\n    '900',\n    'bold',\n    'lighter',\n    'bolder',\n  ]),\n  stretch: new Set([\n    'ultra-condensed',\n    'extra-condensed',\n    'condensed',\n    'semi-condensed',\n    'semi-expanded',\n    'expanded',\n    'extra-expanded',\n    'ultra-expanded',\n  ]),\n  size: new Set([\n    'xx-small',\n    'x-small',\n    'small',\n    'medium',\n    'large',\n    'x-large',\n    'xx-large',\n    'larger',\n    'smaller',\n  ]),\n};\n"]}