{"version":3,"sources":["index.js","isColorStop.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\nconst { getArguments } = require('cssnano-utils');\nconst isColorStop = require('./isColorStop.js');\n\nconst angles = {\n  top: '0deg',\n  right: '90deg',\n  bottom: '180deg',\n  left: '270deg',\n};\n\n/**\n * @param {valueParser.Dimension} a\n * @param {valueParser.Dimension} b\n * @return {boolean}\n */\nfunction isLessThan(a, b) {\n  return (\n    a.unit.toLowerCase() === b.unit.toLowerCase() &&\n    parseFloat(a.number) >= parseFloat(b.number)\n  );\n}\n/**\n * @param {import('postcss').Declaration} decl\n * @return {void}\n */\nfunction optimise(decl) {\n  const value = decl.value;\n\n  if (!value) {\n    return;\n  }\n\n  const normalizedValue = value.toLowerCase();\n\n  if (normalizedValue.includes('var(') || normalizedValue.includes('env(')) {\n    return;\n  }\n\n  if (!normalizedValue.includes('gradient')) {\n    return;\n  }\n\n  decl.value = valueParser(value)\n    .walk((node) => {\n      if (node.type !== 'function' || !node.nodes.length) {\n        return false;\n      }\n\n      const lowerCasedValue = node.value.toLowerCase();\n\n      if (\n        lowerCasedValue === 'linear-gradient' ||\n        lowerCasedValue === 'repeating-linear-gradient' ||\n        lowerCasedValue === '-webkit-linear-gradient' ||\n        lowerCasedValue === '-webkit-repeating-linear-gradient'\n      ) {\n        let args = getArguments(node);\n\n        if (\n          node.nodes[0].value.toLowerCase() === 'to' &&\n          args[0].length === 3\n        ) {\n          node.nodes = node.nodes.slice(2);\n          node.nodes[0].value =\n            angles[\n              /** @type {'top'|'right'|'bottom'|'left'}*/ (\n                node.nodes[0].value.toLowerCase()\n              )\n            ];\n        }\n\n        /** @type {valueParser.Dimension | false} */\n        let lastStop;\n\n        args.forEach((arg, index) => {\n          if (arg.length !== 3) {\n            return;\n          }\n\n          let isFinalStop = index === args.length - 1;\n          let thisStop = valueParser.unit(arg[2].value);\n\n          if (lastStop === undefined) {\n            lastStop = thisStop;\n\n            if (\n              !isFinalStop &&\n              lastStop &&\n              lastStop.number === '0' &&\n              lastStop.unit.toLowerCase() !== 'deg'\n            ) {\n              arg[1].value = arg[2].value = '';\n            }\n\n            return;\n          }\n\n          if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {\n            arg[2].value = '0';\n          }\n\n          lastStop = thisStop;\n\n          if (isFinalStop && arg[2].value === '100%') {\n            arg[1].value = arg[2].value = '';\n          }\n        });\n\n        return false;\n      }\n\n      if (\n        lowerCasedValue === 'radial-gradient' ||\n        lowerCasedValue === 'repeating-radial-gradient'\n      ) {\n        let args = getArguments(node);\n        /** @type {valueParser.Dimension | false} */\n        let lastStop;\n\n        const hasAt = args[0].find((n) => n.value.toLowerCase() === 'at');\n\n        args.forEach((arg, index) => {\n          if (!arg[2] || (!index && hasAt)) {\n            return;\n          }\n\n          let thisStop = valueParser.unit(arg[2].value);\n\n          if (!lastStop) {\n            lastStop = thisStop;\n\n            return;\n          }\n\n          if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {\n            arg[2].value = '0';\n          }\n\n          lastStop = thisStop;\n        });\n\n        return false;\n      }\n\n      if (\n        lowerCasedValue === '-webkit-radial-gradient' ||\n        lowerCasedValue === '-webkit-repeating-radial-gradient'\n      ) {\n        let args = getArguments(node);\n        /** @type {valueParser.Dimension | false} */\n        let lastStop;\n\n        args.forEach((arg) => {\n          let color;\n          let stop;\n\n          if (arg[2] !== undefined) {\n            if (arg[0].type === 'function') {\n              color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;\n            } else {\n              color = arg[0].value;\n            }\n\n            if (arg[2].type === 'function') {\n              stop = `${arg[2].value}(${valueParser.stringify(arg[2].nodes)})`;\n            } else {\n              stop = arg[2].value;\n            }\n          } else {\n            if (arg[0].type === 'function') {\n              color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;\n            }\n\n            color = arg[0].value;\n          }\n\n          color = color.toLowerCase();\n\n          const colorStop =\n            stop !== undefined\n              ? isColorStop(color, stop.toLowerCase())\n              : isColorStop(color);\n\n          if (!colorStop || !arg[2]) {\n            return;\n          }\n\n          let thisStop = valueParser.unit(arg[2].value);\n\n          if (!lastStop) {\n            lastStop = thisStop;\n\n            return;\n          }\n\n          if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {\n            arg[2].value = '0';\n          }\n\n          lastStop = thisStop;\n        });\n\n        return false;\n      }\n    })\n    .toString();\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-minify-gradients',\n    OnceExit(css) {\n      css.walkDecls(optimise);\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst { unit } = require('postcss-value-parser');\nconst { colord, extend } = require('colord');\nconst namesPlugin = require('colord/plugins/names');\n\nextend([/** @type {any} */ (namesPlugin)]);\n\n/* Code derived from https://github.com/pigcan/is-color-stop */\n\nconst lengthUnits = new Set([\n  'PX',\n  'IN',\n  'CM',\n  'MM',\n  'EM',\n  'REM',\n  'POINTS',\n  'PC',\n  'EX',\n  'CH',\n  'VW',\n  'VH',\n  'VMIN',\n  'VMAX',\n  '%',\n]);\n\n/**\n * @param {string} input\n * @return {boolean}\n */\nfunction isCSSLengthUnit(input) {\n  return lengthUnits.has(input.toUpperCase());\n}\n/**\n * @param {string|undefined} str\n * @return {boolean}\n */\nfunction isStop(str) {\n  if (str) {\n    let stop = false;\n    const node = unit(str);\n    if (node) {\n      const number = Number(node.number);\n      if (number === 0 || (!isNaN(number) && isCSSLengthUnit(node.unit))) {\n        stop = true;\n      }\n    } else {\n      stop = /^calc\\(\\S+\\)$/g.test(str);\n    }\n    return stop;\n  }\n  return true;\n}\n/**\n * @param {string} color\n * @param {string} [stop]\n * @return {boolean}\n */\nmodule.exports = function isColorStop(color, stop) {\n  return colord(color).isValid() && isStop(stop);\n};\n"]}