{"version":3,"sources":["index.js","lib/ensureCompatibility.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst browserslist = require('browserslist');\nconst { sameParent } = require('cssnano-utils');\nconst {\n  ensureCompatibility,\n  sameVendor,\n  noVendor,\n} = require('./lib/ensureCompatibility');\n\n/**\n * @param {import('postcss').Declaration} a\n * @param {import('postcss').Declaration} b\n * @return {boolean}\n */\nfunction declarationIsEqual(a, b) {\n  return (\n    a.important === b.important && a.prop === b.prop && a.value === b.value\n  );\n}\n\n/**\n * @param {import('postcss').Declaration[]} array\n * @param {import('postcss').Declaration} decl\n * @return {number}\n */\nfunction indexOfDeclaration(array, decl) {\n  return array.findIndex((d) => declarationIsEqual(d, decl));\n}\n\n/**\n * Returns filtered array of matched or unmatched declarations\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @param {boolean} [not=false]\n * @return {import('postcss').Declaration[]}\n */\nfunction intersect(a, b, not) {\n  return a.filter((c) => {\n    const index = indexOfDeclaration(b, c) !== -1;\n    return not ? !index : index;\n  });\n}\n\n/**\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @return {boolean}\n */\nfunction sameDeclarationsAndOrder(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return a.every((d, index) => declarationIsEqual(d, b[index]));\n}\n\n/**\n * @param {import('postcss').Rule} ruleA\n * @param {import('postcss').Rule} ruleB\n * @param {string[]=} browsers\n * @param {Map<string, boolean>=} compatibilityCache\n * @return {boolean}\n */\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n  const a = ruleA.selectors;\n  const b = ruleB.selectors;\n\n  const selectors = a.concat(b);\n\n  if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {\n    return false;\n  }\n\n  const parent = sameParent(\n    /** @type {any} */ (ruleA),\n    /** @type {any} */ (ruleB)\n  );\n  if (\n    parent &&\n    ruleA.parent &&\n    ruleA.parent.type === 'atrule' &&\n    /** @type {import('postcss').AtRule} */ (ruleA.parent).name.includes(\n      'keyframes'\n    )\n  ) {\n    return false;\n  }\n  return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n\n/**\n * @param {import('postcss').ChildNode} node\n * @return {node is import('postcss').Declaration}\n */\nfunction isDeclaration(node) {\n  return node.type === 'decl';\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {import('postcss').Declaration[]}\n */\nfunction getDecls(rule) {\n  return rule.nodes.filter(isDeclaration);\n}\n\n/** @type {(...rules: import('postcss').Rule[]) => string} */\nconst joinSelectors = (...rules) => rules.map((s) => s.selector).join();\n\n/**\n * @param {...import('postcss').Rule} rules\n * @return {number}\n */\nfunction ruleLength(...rules) {\n  return rules.map((r) => (r.nodes.length ? String(r) : '')).join('').length;\n}\n\n/**\n * @param {string} prop\n * @return {{prefix: string?, base:string?, rest:string[]}}\n */\nfunction splitProp(prop) {\n  // Treat vendor prefixed properties as if they were unprefixed;\n  // moving them when combined with non-prefixed properties can\n  // cause issues. e.g. moving -webkit-background-clip when there\n  // is a background shorthand definition.\n\n  const parts = prop.split('-');\n  if (prop[0] !== '-') {\n    return {\n      prefix: '',\n      base: parts[0],\n      rest: parts.slice(1),\n    };\n  }\n  // Don't split css variables\n  if (prop[1] === '-') {\n    return {\n      prefix: null,\n      base: null,\n      rest: [prop],\n    };\n  }\n  // Found prefix\n  return {\n    prefix: parts[1],\n    base: parts[2],\n    rest: parts.slice(3),\n  };\n}\n\n/**\n * @param {string} propA\n * @param {string} propB\n * @return {boolean}\n */\nfunction isConflictingProp(propA, propB) {\n  if (propA === propB) {\n    // Same specificity\n    return true;\n  }\n  const a = splitProp(propA);\n  const b = splitProp(propB);\n  // Don't resort css variables\n  if (!a.base && !b.base) {\n    return true;\n  }\n\n  // Different base and none is `place`;\n  if (a.base !== b.base && a.base !== 'place' && b.base !== 'place') {\n    return false;\n  }\n\n  // Conflict if rest-count mismatches\n  if (a.rest.length !== b.rest.length) {\n    return true;\n  }\n\n  /* Do not merge conflicting border properties */\n  if (a.base === 'border') {\n    const allRestProps = new Set([...a.rest, ...b.rest]);\n    if (\n      allRestProps.has('image') ||\n      allRestProps.has('width') ||\n      allRestProps.has('color') ||\n      allRestProps.has('style')\n    ) {\n      return true;\n    }\n  }\n  // Conflict if rest parameters are equal (same but unprefixed)\n  return a.rest.every((s, index) => b.rest[index] === s);\n}\n\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {boolean} merged\n */\nfunction mergeParents(first, second) {\n  // Null check for detached rules\n  if (!first.parent || !second.parent) {\n    return false;\n  }\n\n  // Check if parents share node\n  if (first.parent === second.parent) {\n    return false;\n  }\n\n  // sameParent() already called by canMerge()\n\n  second.remove();\n  first.parent.append(second);\n  return true;\n}\n\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {import('postcss').Rule} mergedRule\n */\nfunction partialMerge(first, second) {\n  let intersection = intersect(getDecls(first), getDecls(second));\n  if (intersection.length === 0) {\n    return second;\n  }\n  let nextRule = second.next();\n  if (!nextRule) {\n    // Grab next cousin\n    /** @type {any} */\n    const parentSibling =\n      /** @type {import('postcss').Container<import('postcss').ChildNode>} */ (\n        second.parent\n      ).next();\n    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];\n  }\n  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n    if (nextIntersection.length > intersection.length) {\n      mergeParents(second, nextRule);\n      first = second;\n      second = nextRule;\n      intersection = nextIntersection;\n    }\n  }\n\n  const firstDecls = getDecls(first);\n  // Filter out intersections with later conflicts in First\n  intersection = intersection.filter((decl, intersectIndex) => {\n    const indexOfDecl = indexOfDeclaration(firstDecls, decl);\n    const nextConflictInFirst = firstDecls\n      .slice(indexOfDecl + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (nextConflictInFirst.length === 0) {\n      return true;\n    }\n    const nextConflictInIntersection = intersection\n      .slice(intersectIndex + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {\n      return false;\n    }\n    return nextConflictInFirst.every((d, index) =>\n      declarationIsEqual(d, nextConflictInIntersection[index])\n    );\n  });\n\n  // Filter out intersections with previous conflicts in Second\n  const secondDecls = getDecls(second);\n  intersection = intersection.filter((decl) => {\n    const nextConflictIndex = secondDecls.findIndex((d) =>\n      isConflictingProp(d.prop, decl.prop)\n    );\n    if (nextConflictIndex === -1) {\n      return false;\n    }\n    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {\n      return false;\n    }\n    if (\n      decl.prop.toLowerCase() !== 'direction' &&\n      decl.prop.toLowerCase() !== 'unicode-bidi' &&\n      secondDecls.some(\n        (declaration) => declaration.prop.toLowerCase() === 'all'\n      )\n    ) {\n      return false;\n    }\n    secondDecls.splice(nextConflictIndex, 1);\n    return true;\n  });\n\n  if (intersection.length === 0) {\n    // Nothing to merge\n    return second;\n  }\n\n  const receivingBlock = second.clone();\n  receivingBlock.selector = joinSelectors(first, second);\n  receivingBlock.nodes = [];\n\n  /** @type {import('postcss').Container<import('postcss').ChildNode>} */ (\n    second.parent\n  ).insertBefore(second, receivingBlock);\n\n  const firstClone = first.clone();\n  const secondClone = second.clone();\n\n  /**\n   * @param {function(import('postcss').Declaration):void} callback\n   * @this {import('postcss').Rule}\n   * @return {function(import('postcss').Declaration)}\n   */\n  function moveDecl(callback) {\n    return (decl) => {\n      if (indexOfDeclaration(intersection, decl) !== -1) {\n        callback.call(this, decl);\n      }\n    };\n  }\n  firstClone.walkDecls(\n    moveDecl((decl) => {\n      decl.remove();\n      receivingBlock.append(decl);\n    })\n  );\n  secondClone.walkDecls(moveDecl((decl) => decl.remove()));\n  const merged = ruleLength(firstClone, receivingBlock, secondClone);\n  const original = ruleLength(first, second);\n  if (merged < original) {\n    first.replaceWith(firstClone);\n    second.replaceWith(secondClone);\n    [firstClone, receivingBlock, secondClone].forEach((r) => {\n      if (r.nodes.length === 0) {\n        r.remove();\n      }\n    });\n    if (!secondClone.parent) {\n      return receivingBlock;\n    }\n    return secondClone;\n  } else {\n    receivingBlock.remove();\n    return second;\n  }\n}\n\n/**\n * @param {string[]} browsers\n * @param {Map<string, boolean>} compatibilityCache\n * @return {function(import('postcss').Rule)}\n */\nfunction selectorMerger(browsers, compatibilityCache) {\n  /** @type {import('postcss').Rule | null} */\n  let cache = null;\n  return function (rule) {\n    // Prime the cache with the first rule, or alternately ensure that it is\n    // safe to merge both declarations before continuing\n    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n      cache = rule;\n      return;\n    }\n    // Ensure that we don't deduplicate the same rule; this is sometimes\n    // caused by a partial merge\n    if (cache === rule) {\n      cache = rule;\n      return;\n    }\n\n    // Parents merge: check if the rules have same parents, but not same parent nodes\n    mergeParents(cache, rule);\n\n    // Merge when declarations are exactly equal\n    // e.g. h1 { color: red } h2 { color: red }\n    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {\n      rule.selector = joinSelectors(cache, rule);\n      cache.remove();\n      cache = rule;\n      return;\n    }\n    // Merge when both selectors are exactly equal\n    // e.g. a { color: blue } a { font-weight: bold }\n    if (cache.selector === rule.selector) {\n      const cached = getDecls(cache);\n      rule.walk((node) => {\n        if (node.type === 'decl' && indexOfDeclaration(cached, node) !== -1) {\n          node.remove();\n          return;\n        }\n        /** @type {import('postcss').Rule} */ (cache).append(node);\n      });\n      rule.remove();\n      return;\n    }\n    // Partial merge: check if the rule contains a subset of the last; if\n    // so create a joined selector with the subset, if smaller.\n    cache = partialMerge(cache, rule);\n  };\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-rules',\n\n    prepare(result) {\n      /** @type {typeof result.opts & browserslist.Options} */\n      const resultOpts = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOpts.stats,\n        path: __dirname,\n        env: resultOpts.env,\n      });\n\n      const compatibilityCache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkRules(selectorMerger(browsers, compatibilityCache));\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst { isSupported } = require('caniuse-api');\nconst selectorParser = require('postcss-selector-parser');\n\nconst simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;\n\nconst cssSel2 = 'css-sel2';\nconst cssSel3 = 'css-sel3';\nconst cssGencontent = 'css-gencontent';\nconst cssFirstLetter = 'css-first-letter';\nconst cssFirstLine = 'css-first-line';\nconst cssInOutOfRange = 'css-in-out-of-range';\nconst formValidation = 'form-validation';\n\nconst vendorPrefix =\n  /-(ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)-/;\n\nconst level2Sel = new Set(['=', '~=', '|=']);\nconst level3Sel = new Set(['^=', '$=', '*=']);\n\n/**\n * @param {string} selector\n * @return {RegExpMatchArray | null}\n */\nfunction filterPrefixes(selector) {\n  return selector.match(vendorPrefix);\n}\n\n/**\n * Internet Explorer use :-ms-input-placeholder.\n * Microsoft Edge use ::-ms-input-placeholder.\n *\n * @type {(selector: string) => number}\n */\nconst findMsInputPlaceholder = (selector) =>\n  ~selector.search(/-ms-input-placeholder/i);\n\n/**\n * @param {string[]} selectorsA\n * @param {string[]} selectorsB\n * @return {boolean}\n */\nfunction sameVendor(selectorsA, selectorsB) {\n  /** @type {(selectors: string[]) => string} */\n  let same = (selectors) => selectors.map(filterPrefixes).join();\n  /** @type {(selectors: string[]) => string | undefined} */\n  let findMsVendor = (selectors) => selectors.find(findMsInputPlaceholder);\n  return (\n    same(selectorsA) === same(selectorsB) &&\n    !(findMsVendor(selectorsA) && findMsVendor(selectorsB))\n  );\n}\n\n/**\n * @param {string} selector\n * @return {boolean}\n */\nfunction noVendor(selector) {\n  return !vendorPrefix.test(selector);\n}\n\nconst pseudoElements = {\n  ':active': cssSel2,\n  ':after': cssGencontent,\n  ':any-link': 'css-any-link',\n  ':before': cssGencontent,\n  ':checked': cssSel3,\n  ':default': 'css-default-pseudo',\n  ':dir': 'css-dir-pseudo',\n  ':disabled': cssSel3,\n  ':empty': cssSel3,\n  ':enabled': cssSel3,\n  ':first-child': cssSel2,\n  ':first-letter': cssFirstLetter,\n  ':first-line': cssFirstLine,\n  ':first-of-type': cssSel3,\n  ':focus': cssSel2,\n  ':focus-within': 'css-focus-within',\n  ':focus-visible': 'css-focus-visible',\n  ':has': 'css-has',\n  ':hover': cssSel2,\n  ':in-range': cssInOutOfRange,\n  ':indeterminate': 'css-indeterminate-pseudo',\n  ':invalid': formValidation,\n  ':is': 'css-matches-pseudo',\n  ':lang': cssSel2,\n  ':last-child': cssSel3,\n  ':last-of-type': cssSel3,\n  ':link': cssSel2,\n  ':matches': 'css-matches-pseudo',\n  ':not': cssSel3,\n  ':nth-child': cssSel3,\n  ':nth-last-child': cssSel3,\n  ':nth-last-of-type': cssSel3,\n  ':nth-of-type': cssSel3,\n  ':only-child': cssSel3,\n  ':only-of-type': cssSel3,\n  ':optional': 'css-optional-pseudo',\n  ':out-of-range': cssInOutOfRange,\n  ':placeholder-shown': 'css-placeholder-shown',\n  ':required': formValidation,\n  ':root': cssSel3,\n  ':target': cssSel3,\n  '::after': cssGencontent,\n  '::backdrop': 'dialog',\n  '::before': cssGencontent,\n  '::first-letter': cssFirstLetter,\n  '::first-line': cssFirstLine,\n  '::marker': 'css-marker-pseudo',\n  '::placeholder': 'css-placeholder',\n  '::selection': 'css-selection',\n  ':valid': formValidation,\n  ':visited': cssSel2,\n};\n\n/**\n * @param {string} selector\n * @return {boolean}\n */\nfunction isCssMixin(selector) {\n  return selector[selector.length - 1] === ':';\n}\n\n/**\n * @param {string} selector\n * @return {boolean}\n */\nfunction isHostPseudoClass(selector) {\n  return selector.includes(':host');\n}\n\nconst isSupportedCache = new Map();\n\n// Move to util in future\n/**\n * @param {string} feature\n * @param {string[] | undefined} browsers\n */\nfunction isSupportedCached(feature, browsers) {\n  const key = JSON.stringify({ feature, browsers });\n  let result = isSupportedCache.get(key);\n\n  if (!result) {\n    result = isSupported(feature, /** @type {string[]} */ (browsers));\n    isSupportedCache.set(key, result);\n  }\n\n  return result;\n}\n\n/**\n * @param {string[]} selectors\n * @param{string[]=} browsers\n * @param{Map<string,boolean>=} compatibilityCache\n * @return {boolean}\n */\nfunction ensureCompatibility(selectors, browsers, compatibilityCache) {\n  // Should not merge mixins\n  if (selectors.some(isCssMixin)) {\n    return false;\n  }\n\n  // Should not merge :host selector https://github.com/angular/angular-cli/issues/18672\n  if (selectors.some(isHostPseudoClass)) {\n    return false;\n  }\n  return selectors.every((selector) => {\n    if (simpleSelectorRe.test(selector)) {\n      return true;\n    }\n    if (compatibilityCache && compatibilityCache.has(selector)) {\n      return compatibilityCache.get(selector);\n    }\n    let compatible = true;\n    selectorParser((ast) => {\n      ast.walk((node) => {\n        const { type, value } = node;\n        if (type === 'pseudo') {\n          const entry =\n            pseudoElements[/** @type {keyof pseudoElements} */ (value)];\n          if (!entry && noVendor(value)) {\n            compatible = false;\n          }\n          if (entry && compatible) {\n            compatible = isSupportedCached(entry, browsers);\n          }\n        }\n        if (type === 'combinator') {\n          if (value.includes('~')) {\n            compatible = isSupportedCached(cssSel3, browsers);\n          }\n          if (value.includes('>') || value.includes('+')) {\n            compatible = isSupportedCached(cssSel2, browsers);\n          }\n        }\n        if (type === 'attribute' && node.attribute) {\n          // [foo]\n          if (!node.operator) {\n            compatible = isSupportedCached(cssSel2, browsers);\n          }\n          if (value) {\n            // [foo=\"bar\"], [foo~=\"bar\"], [foo|=\"bar\"]\n            if (level2Sel.has(/** @type {string} */ (node.operator))) {\n              compatible = isSupportedCached(cssSel2, browsers);\n            }\n            // [foo^=\"bar\"], [foo$=\"bar\"], [foo*=\"bar\"]\n            if (level3Sel.has(/** @type {string} */ (node.operator))) {\n              compatible = isSupportedCached(cssSel3, browsers);\n            }\n          }\n\n          // [foo=\"bar\" i]\n          if (node.insensitive) {\n            compatible = isSupportedCached('css-case-insensitive', browsers);\n          }\n        }\n        if (!compatible) {\n          // If this node was not compatible,\n          // break out early from walking the rest\n          return false;\n        }\n      });\n    }).processSync(selector);\n    if (compatibilityCache) {\n      compatibilityCache.set(selector, compatible);\n    }\n    return compatible;\n  });\n}\n\nmodule.exports = { sameVendor, noVendor, pseudoElements, ensureCompatibility };\n"]}