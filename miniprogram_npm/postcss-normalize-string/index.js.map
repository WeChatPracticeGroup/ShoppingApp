{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\n\n/*\n * Constants (parser usage)\n */\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\n\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\\\'` };\nconst T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\\\\"` };\nconst T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };\nconst T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };\nconst T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };\n\n/** @typedef {T_ESCAPED_SINGLE_QUOTE | T_ESCAPED_DOUBLE_QUOTE | T_SINGLE_QUOTE | T_NEWLINE} StringAstNode */\n/**\n * @typedef {{nodes: StringAstNode[],\n *            types: {escapedSingleQuote: number, escapedDoubleQuote: number, singleQuote: number, doubleQuote: number},\n *            quotes: boolean}} StringAst\n */\n\n/**\n * @param {StringAst} ast\n * @return {string}\n */\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, { value }) => {\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n\n/**\n * @param {string} str\n * @return {StringAst}\n */\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n\n  /** @type StringAst */\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0,\n    },\n    quotes: false,\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        );\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next),\n        });\n        pos = next - 1;\n        break;\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n\n        ast.nodes.push({\n          type: C_STRING,\n          value,\n        });\n\n        pos = next;\n    }\n    pos++;\n  }\n\n  return ast;\n}\n\n/**\n * @param {valueParser.StringNode} node\n * @param {StringAst} ast\n * @return {void}\n */\nfunction changeWrappingQuotes(node, ast) {\n  const { types } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (\n    node.quote === L_SINGLE_QUOTE &&\n    types[C_ESCAPED_SINGLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_DOUBLE_QUOTE]\n  ) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (\n    node.quote === L_DOUBLE_QUOTE &&\n    types[C_ESCAPED_DOUBLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_SINGLE_QUOTE]\n  ) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = changeChildQuotes(ast.nodes, node.quote);\n}\n/**\n * @param {StringAstNode[]} childNodes\n * @param {string} parentQuote\n * @return {StringAstNode[]}\n */\nfunction changeChildQuotes(childNodes, parentQuote) {\n  const updatedChildren = [];\n  for (const child of childNodes) {\n    if (\n      child.type === C_ESCAPED_DOUBLE_QUOTE &&\n      parentQuote === L_SINGLE_QUOTE\n    ) {\n      updatedChildren.push(T_DOUBLE_QUOTE);\n    } else if (\n      child.type === C_ESCAPED_SINGLE_QUOTE &&\n      parentQuote === L_DOUBLE_QUOTE\n    ) {\n      updatedChildren.push(T_SINGLE_QUOTE);\n    } else {\n      updatedChildren.push(child);\n    }\n  }\n  return updatedChildren;\n}\n\n/**\n * @param {string} value\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return valueParser(value)\n    .walk((child) => {\n      if (child.type !== C_STRING) {\n        return;\n      }\n\n      const ast = parse(child.value);\n\n      if (ast.quotes) {\n        changeWrappingQuotes(child, ast);\n      } else if (preferredQuote === C_SINGLE) {\n        child.quote = L_SINGLE_QUOTE;\n      } else {\n        child.quote = L_DOUBLE_QUOTE;\n      }\n\n      child.value = stringify(ast);\n    })\n    .toString();\n}\n\n/**\n * @param {string} original\n * @param {Map<string, string>} cache\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\nfunction minify(original, cache, preferredQuote) {\n  const key = original + '|' + preferredQuote;\n  if (cache.has(key)) {\n    return /** @type {string} */ (cache.get(key));\n  }\n  const newValue = normalize(original, preferredQuote);\n  cache.set(key, newValue);\n  return newValue;\n}\n\n/** @typedef {{preferredQuote?: 'double' | 'single'}} Options */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts) {\n  const { preferredQuote } = Object.assign(\n    {},\n    {\n      preferredQuote: 'double',\n    },\n    opts\n  );\n\n  return {\n    postcssPlugin: 'postcss-normalize-string',\n\n    OnceExit(css) {\n      const cache = new Map();\n\n      css.walk((node) => {\n        switch (node.type) {\n          case 'rule':\n            node.selector = minify(node.selector, cache, preferredQuote);\n            break;\n          case 'decl':\n            node.value = minify(node.value, cache, preferredQuote);\n            break;\n          case 'atrule':\n            node.params = minify(node.params, cache, preferredQuote);\n            break;\n        }\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]}