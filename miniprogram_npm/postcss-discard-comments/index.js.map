{"version":3,"sources":["index.js","lib/commentRemover.js","lib/commentParser.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst CommentRemover = require('./lib/commentRemover');\nconst commentParser = require('./lib/commentParser');\n\n/** @typedef {object} Options\n *  @property {boolean=} removeAll\n *  @property {boolean=} removeAllButFirst\n *  @property {(s: string) => boolean=} remove\n */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts = {}) {\n  const remover = new CommentRemover(opts);\n  const matcherCache = new Map();\n  const replacerCache = new Map();\n\n  /**\n   * @param {string} source\n   * @return {[number, number, number][]}\n   */\n  function matchesComments(source) {\n    if (matcherCache.has(source)) {\n      return matcherCache.get(source);\n    }\n\n    const result = commentParser(source).filter(([type]) => type);\n\n    matcherCache.set(source, result);\n\n    return result;\n  }\n\n  /**\n   * @param {string} source\n   * @param {(s: string) => string[]} space\n   * @return {string}\n   */\n  function replaceComments(source, space, separator = ' ') {\n    const key = source + '@|@' + separator;\n\n    if (replacerCache.has(key)) {\n      return replacerCache.get(key);\n    }\n    const parsed = commentParser(source).reduce((value, [type, start, end]) => {\n      const contents = source.slice(start, end);\n\n      if (!type) {\n        return value + contents;\n      }\n\n      if (remover.canRemove(contents)) {\n        return value + separator;\n      }\n\n      return `${value}/*${contents}*/`;\n    }, '');\n\n    const result = space(parsed).join(' ');\n\n    replacerCache.set(key, result);\n\n    return result;\n  }\n\n  return {\n    postcssPlugin: 'postcss-discard-comments',\n\n    OnceExit(css, { list }) {\n      css.walk((node) => {\n        if (node.type === 'comment' && remover.canRemove(node.text)) {\n          node.remove();\n\n          return;\n        }\n\n        if (typeof node.raws.between === 'string') {\n          node.raws.between = replaceComments(node.raws.between, list.space);\n        }\n\n        if (node.type === 'decl') {\n          if (node.raws.value && node.raws.value.raw) {\n            if (node.raws.value.value === node.value) {\n              node.value = replaceComments(node.raws.value.raw, list.space);\n            } else {\n              node.value = replaceComments(node.value, list.space);\n            }\n\n            /** @type {null | {value: string, raw: string}} */ (\n              node.raws.value\n            ) = null;\n          }\n\n          if (node.raws.important) {\n            node.raws.important = replaceComments(\n              node.raws.important,\n              list.space\n            );\n\n            const b = matchesComments(node.raws.important);\n\n            node.raws.important = b.length ? node.raws.important : '!important';\n          } else {\n            node.value = replaceComments(node.value, list.space);\n          }\n\n          return;\n        }\n\n        if (\n          node.type === 'rule' &&\n          node.raws.selector &&\n          node.raws.selector.raw\n        ) {\n          node.raws.selector.raw = replaceComments(\n            node.raws.selector.raw,\n            list.space,\n            ''\n          );\n\n          return;\n        }\n\n        if (node.type === 'atrule') {\n          if (node.raws.afterName) {\n            const commentsReplaced = replaceComments(\n              node.raws.afterName,\n              list.space\n            );\n\n            if (!commentsReplaced.length) {\n              node.raws.afterName = commentsReplaced + ' ';\n            } else {\n              node.raws.afterName = ' ' + commentsReplaced + ' ';\n            }\n          }\n\n          if (node.raws.params && node.raws.params.raw) {\n            node.raws.params.raw = replaceComments(\n              node.raws.params.raw,\n              list.space\n            );\n          }\n        }\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\n\n/** @param {import('../index.js').Options} options */\nfunction CommentRemover(options) {\n  this.options = options;\n}\n/**\n * @param {string} comment\n * @return {boolean | undefined}\n */\nCommentRemover.prototype.canRemove = function (comment) {\n  const remove = this.options.remove;\n\n  if (remove) {\n    return remove(comment);\n  } else {\n    const isImportant = comment.indexOf('!') === 0;\n\n    if (!isImportant) {\n      return true;\n    }\n\n    if (this.options.removeAll || this._hasFirst) {\n      return true;\n    } else if (this.options.removeAllButFirst && !this._hasFirst) {\n      this._hasFirst = true;\n      return false;\n    }\n  }\n};\n\nmodule.exports = CommentRemover;\n","\n\n/**\n * @param {string} input\n * @return {[number, number, number][]}\n */\nmodule.exports = function commentParser(input) {\n  /** @type [number, number, number][] */\n  const tokens = [];\n  const length = input.length;\n  let pos = 0;\n  let next;\n\n  while (pos < length) {\n    next = input.indexOf('/*', pos);\n\n    if (~next) {\n      tokens.push([0, pos, next]);\n      pos = next;\n\n      next = input.indexOf('*/', pos + 2);\n      tokens.push([1, pos + 2, next]);\n      pos = next + 2;\n    } else {\n      tokens.push([0, pos, length]);\n      pos = length;\n    }\n  }\n\n  return tokens;\n};\n"]}