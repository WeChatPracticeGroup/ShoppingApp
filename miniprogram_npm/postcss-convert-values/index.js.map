{"version":3,"sources":["index.js","lib/convert.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\nconst browserslist = require('browserslist');\nconst convert = require('./lib/convert.js');\n\nconst LENGTH_UNITS = new Set([\n  'em',\n  'ex',\n  'ch',\n  'rem',\n  'vw',\n  'vh',\n  'vmin',\n  'vmax',\n  'cm',\n  'mm',\n  'q',\n  'in',\n  'pt',\n  'pc',\n  'px',\n]);\n\n// These properties only accept percentages, so no point in trying to transform\nconst notALength = new Set([\n  'descent-override',\n  'ascent-override',\n  'font-stretch',\n  'size-adjust',\n  'line-gap-override',\n]);\n\n// Can't change the unit on these properties when they're 0\nconst keepWhenZero = new Set([\n  'stroke-dashoffset',\n  'stroke-width',\n  'line-height',\n]);\n\n// Can't remove the % on these properties when they're 0 on IE 11\nconst keepZeroPercent = new Set(['max-height', 'height', 'min-width']);\n\n/**\n * Numbers without digits after the dot are technically invalid,\n * but in that case css-value-parser returns the dot as part of the unit,\n * so we use this to remove the dot.\n *\n * @param {string} item\n * @return {string}\n */\nfunction stripLeadingDot(item) {\n  if (item.charCodeAt(0) === '.'.charCodeAt(0)) {\n    return item.slice(1);\n  } else {\n    return item;\n  }\n}\n\n/**\n * @param {valueParser.Node} node\n * @param {Options} opts\n * @param {boolean} keepZeroUnit\n * @return {void}\n */\nfunction parseWord(node, opts, keepZeroUnit) {\n  const pair = valueParser.unit(node.value);\n  if (pair) {\n    const num = Number(pair.number);\n    const u = stripLeadingDot(pair.unit);\n    if (num === 0) {\n      node.value =\n        0 +\n        (keepZeroUnit || (!LENGTH_UNITS.has(u.toLowerCase()) && u !== '%')\n          ? u\n          : '');\n    } else {\n      node.value = convert(num, u, opts);\n\n      if (\n        typeof opts.precision === 'number' &&\n        u.toLowerCase() === 'px' &&\n        pair.number.includes('.')\n      ) {\n        const precision = Math.pow(10, opts.precision);\n        node.value =\n          Math.round(parseFloat(node.value) * precision) / precision + u;\n      }\n    }\n  }\n}\n\n/**\n * @param {valueParser.WordNode} node\n * @return {void}\n */\nfunction clampOpacity(node) {\n  const pair = valueParser.unit(node.value);\n  if (!pair) {\n    return;\n  }\n  let num = Number(pair.number);\n  if (num > 1) {\n    node.value = pair.unit === '%' ? num + pair.unit : 1 + pair.unit;\n  } else if (num < 0) {\n    node.value = 0 + pair.unit;\n  }\n}\n\n/**\n * @param {import('postcss').Declaration} decl\n * @param {string[]} browsers\n * @return {boolean}\n */\nfunction shouldKeepZeroUnit(decl, browsers) {\n  const { parent } = decl;\n  const lowerCasedProp = decl.prop.toLowerCase();\n  return (\n    (decl.value.includes('%') &&\n      keepZeroPercent.has(lowerCasedProp) &&\n      browsers.includes('ie 11')) ||\n    (parent &&\n      parent.parent &&\n      parent.parent.type === 'atrule' &&\n      /** @type {import('postcss').AtRule} */ (\n        parent.parent\n      ).name.toLowerCase() === 'keyframes' &&\n      lowerCasedProp === 'stroke-dasharray') ||\n    keepWhenZero.has(lowerCasedProp)\n  );\n}\n/**\n * @param {Options} opts\n * @param {string[]} browsers\n * @param {import('postcss').Declaration} decl\n * @return {void}\n */\nfunction transform(opts, browsers, decl) {\n  const lowerCasedProp = decl.prop.toLowerCase();\n  if (\n    lowerCasedProp.includes('flex') ||\n    lowerCasedProp.indexOf('--') === 0 ||\n    notALength.has(lowerCasedProp)\n  ) {\n    return;\n  }\n\n  decl.value = valueParser(decl.value)\n    .walk((node) => {\n      const lowerCasedValue = node.value.toLowerCase();\n\n      if (node.type === 'word') {\n        parseWord(node, opts, shouldKeepZeroUnit(decl, browsers));\n        if (\n          lowerCasedProp === 'opacity' ||\n          lowerCasedProp === 'shape-image-threshold'\n        ) {\n          clampOpacity(node);\n        }\n      } else if (node.type === 'function') {\n        if (\n          lowerCasedValue === 'calc' ||\n          lowerCasedValue === 'min' ||\n          lowerCasedValue === 'max' ||\n          lowerCasedValue === 'clamp' ||\n          lowerCasedValue === 'hsl' ||\n          lowerCasedValue === 'hsla'\n        ) {\n          valueParser.walk(node.nodes, (n) => {\n            if (n.type === 'word') {\n              parseWord(n, opts, true);\n            }\n          });\n          return false;\n        }\n        if (lowerCasedValue === 'url') {\n          return false;\n        }\n      }\n    })\n    .toString();\n}\n\nconst plugin = 'postcss-convert-values';\n/**\n * @typedef {{precision: boolean | number, angle?: boolean, time?: boolean, length?: boolean} & browserslist.Options} Options */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts = { precision: false }) {\n  const browsers = browserslist(null, {\n    stats: opts.stats,\n    path: __dirname,\n    env: opts.env,\n  });\n\n  return {\n    postcssPlugin: plugin,\n    OnceExit(css) {\n      css.walkDecls((decl) => transform(opts, browsers, decl));\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst lengthConv = new Map([\n  ['in', 96],\n  ['px', 1],\n  ['pt', 4 / 3],\n  ['pc', 16],\n]);\n\nconst timeConv = new Map([\n  ['s', 1000],\n  ['ms', 1],\n]);\n\nconst angleConv = new Map([\n  ['turn', 360],\n  ['deg', 1],\n]);\n/**\n * @param {number} number\n * @return {string}\n */\nfunction dropLeadingZero(number) {\n  const value = String(number);\n\n  if (number % 1) {\n    if (value[0] === '0') {\n      return value.slice(1);\n    }\n\n    if (value[0] === '-' && value[1] === '0') {\n      return '-' + value.slice(2);\n    }\n  }\n\n  return value;\n}\n/**\n * @param {number} number\n * @param {string} originalUnit\n * @param {lengthConv | timeConv | angleConv} conversions\n * @return {string}\n */\nfunction transform(number, originalUnit, conversions) {\n  let conversionUnits = [...conversions.keys()].filter((u) => {\n    return originalUnit !== u;\n  });\n\n  const base = number * /** @type {number} */ (conversions.get(originalUnit));\n\n  return conversionUnits\n    .map(\n      (u) =>\n        dropLeadingZero(base / /** @type {number} */ (conversions.get(u))) + u\n    )\n    .reduce((a, b) => (a.length < b.length ? a : b));\n}\n\n/**\n * @param {number} number\n * @param {string} unit\n * @param {{time?: boolean, length?: boolean, angle?: boolean}} options\n * @return {string}\n */\nmodule.exports = function (number, unit, { time, length, angle }) {\n  let value = dropLeadingZero(number) + (unit ? unit : '');\n  let converted;\n  const lowerCaseUnit = unit.toLowerCase();\n  if (length !== false && lengthConv.has(lowerCaseUnit)) {\n    converted = transform(number, lowerCaseUnit, lengthConv);\n  }\n\n  if (time !== false && timeConv.has(lowerCaseUnit)) {\n    converted = transform(number, lowerCaseUnit, timeConv);\n  }\n\n  if (angle !== false && angleConv.has(lowerCaseUnit)) {\n    converted = transform(number, lowerCaseUnit, angleConv);\n  }\n\n  if (converted && converted.length < value.length) {\n    value = converted;\n  }\n\n  return value;\n};\n"]}