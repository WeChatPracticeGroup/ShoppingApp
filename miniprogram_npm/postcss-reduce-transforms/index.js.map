{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\n\n/**\n * @param {(number|string)[]} list\n * @param {valueParser.Node} node\n * @param {number} index\n * @return {(number|string)[]}\n */\nfunction getValues(list, node, index) {\n  if (index % 2 === 0) {\n    /** @type {number|string} */\n    let value = NaN;\n\n    if (\n      node.type === 'function' &&\n      (node.value === 'var' || node.value === 'env') &&\n      node.nodes.length === 1\n    ) {\n      value = valueParser.stringify(node.nodes);\n    } else if (node.type === 'word') {\n      value = parseFloat(node.value);\n    }\n\n    return [...list, value];\n  }\n\n  return list;\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction matrix3d(node, values) {\n  if (values.length !== 16) {\n    return;\n  }\n\n  // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)\n  if (\n    values[15] &&\n    values[2] === 0 &&\n    values[3] === 0 &&\n    values[6] === 0 &&\n    values[7] === 0 &&\n    values[8] === 0 &&\n    values[9] === 0 &&\n    values[10] === 1 &&\n    values[11] === 0 &&\n    values[14] === 0 &&\n    values[15] === 1\n  ) {\n    const { nodes } = node;\n\n    node.value = 'matrix';\n    node.nodes = [\n      nodes[0], // a\n      nodes[1], // ,\n      nodes[2], // b\n      nodes[3], // ,\n      nodes[8], // c\n      nodes[9], // ,\n      nodes[10], // d\n      nodes[11], // ,\n      nodes[24], // tx\n      nodes[25], // ,\n      nodes[26], // ty\n    ];\n  }\n}\n\nconst rotate3dMappings = new Map([\n  [[1, 0, 0].toString(), 'rotateX'], // rotate3d(1, 0, 0, a) => rotateX(a)\n  [[0, 1, 0].toString(), 'rotateY'], // rotate3d(0, 1, 0, a) => rotateY(a)\n  [[0, 0, 1].toString(), 'rotate'], // rotate3d(0, 0, 1, a) => rotate(a)\n]);\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction rotate3d(node, values) {\n  if (values.length !== 4) {\n    return;\n  }\n\n  const { nodes } = node;\n  const match = rotate3dMappings.get(values.slice(0, 3).toString());\n\n  if (match) {\n    node.value = match;\n    node.nodes = [nodes[6]];\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction rotateZ(node, values) {\n  if (values.length !== 1) {\n    return;\n  }\n\n  // rotateZ(rz) => rotate(rz)\n  node.value = 'rotate';\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction scale(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second] = values;\n\n  // scale(sx, sy) => scale(sx)\n  if (first === second) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(sx, 1) => scaleX(sx)\n  if (second === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(1, sy) => scaleY(sy)\n  if (first === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction scale3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second, third] = values;\n\n  // scale3d(sx, 1, 1) => scaleX(sx)\n  if (second === 1 && third === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale3d(1, sy, 1) => scaleY(sy)\n  if (first === 1 && third === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n\n  // scale3d(1, 1, sz) => scaleZ(sz)\n  if (first === 1 && second === 1) {\n    node.value = 'scaleZ';\n    node.nodes = [nodes[4]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction translate(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate(tx, 0) => translate(tx)\n  if (values[1] === 0) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // translate(0, ty) => translateY(ty)\n  if (values[0] === 0) {\n    node.value = 'translateY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction translate3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate3d(0, 0, tz) => translateZ(tz)\n  if (values[0] === 0 && values[1] === 0) {\n    node.value = 'translateZ';\n    node.nodes = [nodes[4]];\n  }\n}\n\nconst reducers = new Map([\n  ['matrix3d', matrix3d],\n  ['rotate3d', rotate3d],\n  ['rotateZ', rotateZ],\n  ['scale', scale],\n  ['scale3d', scale3d],\n  ['translate', translate],\n  ['translate3d', translate3d],\n]);\n/**\n * @param {string} name\n * @return {string}\n */\nfunction normalizeReducerName(name) {\n  const lowerCasedName = name.toLowerCase();\n\n  if (lowerCasedName === 'rotatez') {\n    return 'rotateZ';\n  }\n\n  return lowerCasedName;\n}\n\n/**\n * @param {valueParser.Node} node\n * @return {false}\n */\nfunction reduce(node) {\n  if (node.type === 'function') {\n    const normalizedReducerName = normalizeReducerName(node.value);\n    const reducer = reducers.get(normalizedReducerName);\n    if (reducer !== undefined) {\n      reducer(node, node.nodes.reduce(getValues, []));\n    }\n  }\n  return false;\n}\n\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-reduce-transforms',\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/transform$/i, (decl) => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n\n              return;\n            }\n\n            const result = valueParser(value).walk(reduce).toString();\n\n            decl.value = result;\n            cache.set(value, result);\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]}