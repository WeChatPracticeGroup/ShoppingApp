{"version":3,"sources":["index.js","minifyColor.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst browserslist = require('browserslist');\nconst { isSupported } = require('caniuse-api');\nconst valueParser = require('postcss-value-parser');\nconst minifyColor = require('./minifyColor');\n\n/**\n * @param {{nodes: valueParser.Node[]}} parent\n * @param {(node: valueParser.Node, index: number, parent: {nodes: valueParser.Node[]}) => false | undefined} callback\n * @return {void}\n */\nfunction walk(parent, callback) {\n  parent.nodes.forEach((node, index) => {\n    const bubble = callback(node, index, parent);\n\n    if (node.type === 'function' && bubble !== false) {\n      walk(node, callback);\n    }\n  });\n}\n\n/*\n * IE 8 & 9 do not properly handle clicks on elements\n * with a `transparent` `background-color`.\n *\n * https://developer.mozilla.org/en-US/docs/Web/Events/click#Internet_Explorer\n */\nconst browsersWithTransparentBug = new Set(['ie 8', 'ie 9']);\nconst mathFunctions = new Set(['calc', 'min', 'max', 'clamp']);\n\n/**\n * @param {valueParser.Node} node\n * @return {boolean}\n */\nfunction isMathFunctionNode(node) {\n  if (node.type !== 'function') {\n    return false;\n  }\n  return mathFunctions.has(node.value.toLowerCase());\n}\n\n/**\n * @param {string} value\n * @param {Record<string, boolean>} options\n * @return {string}\n */\nfunction transform(value, options) {\n  const parsed = valueParser(value);\n\n  walk(parsed, (node, index, parent) => {\n    if (node.type === 'function') {\n      if (/^(rgb|hsl)a?$/i.test(node.value)) {\n        const { value: originalValue } = node;\n\n        node.value = minifyColor(valueParser.stringify(node), options);\n        /** @type {string} */ (node.type) = 'word';\n\n        const next = parent.nodes[index + 1];\n\n        if (\n          node.value !== originalValue &&\n          next &&\n          (next.type === 'word' || next.type === 'function')\n        ) {\n          parent.nodes.splice(\n            index + 1,\n            0,\n            /** @type {valueParser.SpaceNode} */ ({\n              type: 'space',\n              value: ' ',\n            })\n          );\n        }\n      } else if (isMathFunctionNode(node)) {\n        return false;\n      }\n    } else if (node.type === 'word') {\n      node.value = minifyColor(node.value, options);\n    }\n  });\n\n  return parsed.toString();\n}\n\n/**\n * @param {Record<string, boolean>} options\n * @param {string[]} browsers\n * @return {Record<string, boolean>}\n */\nfunction addPluginDefaults(options, browsers) {\n  const defaults = {\n    // Does the browser support 4 & 8 character hex notation\n    transparent:\n      browsers.some((b) => browsersWithTransparentBug.has(b)) === false,\n    // Does the browser support \"transparent\" value properly\n    alphaHex: isSupported('css-rrggbbaa', browsers),\n    name: true,\n  };\n  return { ...defaults, ...options };\n}\n/**\n * @type {import('postcss').PluginCreator<Record<string, boolean>>}\n * @param {Record<string, boolean>} config\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(config = {}) {\n  return {\n    postcssPlugin: 'postcss-colormin',\n\n    prepare(result) {\n      /** @type {typeof result.opts & browserslist.Options} */\n      const resultOptions = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOptions.stats,\n        path: __dirname,\n        env: resultOptions.env,\n      });\n\n      const cache = new Map();\n      const options = addPluginDefaults(config, browsers);\n\n      return {\n        OnceExit(css) {\n          css.walkDecls((decl) => {\n            if (\n              /^(composes|font|src$|filter|-webkit-tap-highlight-color)/i.test(\n                decl.prop\n              )\n            ) {\n              return;\n            }\n\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            const cacheKey = JSON.stringify({ value, options, browsers });\n\n            if (cache.has(cacheKey)) {\n              decl.value = cache.get(cacheKey);\n\n              return;\n            }\n\n            const newValue = transform(value, options);\n\n            decl.value = newValue;\n            cache.set(cacheKey, newValue);\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst { colord, extend } = require('colord');\nconst namesPlugin = require('colord/plugins/names');\nconst minifierPlugin = require('colord/plugins/minify');\n\nextend(/** @type {any[]} */ ([namesPlugin, minifierPlugin]));\n\n/**\n * Performs color value minification\n *\n * @param {string} input - CSS value\n * @param {Record<string, boolean>} options  object with colord.minify() options\n * @return {string}\n */\nmodule.exports = function minifyColor(input, options = {}) {\n  const instance = colord(input);\n\n  if (instance.isValid()) {\n    // Try to shorten the string if it is a valid CSS color value\n    const minified = instance.minify(options);\n\n    // Fall back to the original input if it's smaller or has equal length\n    return minified.length < input.length ? minified : input.toLowerCase();\n  } else {\n    // Possibly malformed, so pass through\n    return input;\n  }\n};\n"]}