{"version":3,"sources":["index.js","rules/grid.js","lib/joinGridValue.js","rules/animation.js","lib/addSpace.js","lib/getValue.js","rules/border.js","lib/mathfunctions.js","rules/boxShadow.js","lib/vendorUnprefixed.js","rules/flexFlow.js","rules/transition.js","rules/listStyle.js","rules/listStyleTypes.json","rules/columns.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,AFMA,ACHA,AFMA;ADIA,AIZA,ACHA,AFMA,AFMA;ADIA,AIZA,ACHA,AFMA,AFMA;ADIA,AIZA,ACHA,AFMA,AFMA;ADIA,AIZA,ACHA,AFMA,AGTA,ALeA;ADIA,AIZA,ACHA,AFMA,AGTA,ALeA;ADIA,AIZA,ACHA,AFMA,AGTA,ALeA;ADIA,AKfA,AENA,AJYA,AGTA,ALeA;ADIA,AKfA,AENA,AJYA,AGTA,ALeA;ADIA,AKfA,AENA,AJYA,AGTA,ALeA;ADIA,AKfA,AENA,AJYA,AGTA,AENA,APqBA;ADIA,AKfA,AFMA,AGTA,AENA,APqBA;ADIA,AKfA,AFMA,AGTA,AENA,APqBA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,APqBA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,APqBA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,APqBA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA;ADIA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA,AU9BA;AXkCA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA,AU9BA;AXkCA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA,AU9BA;AXkCA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA,AWjCA,ADGA;AXkCA,AKfA,AIZA,ANkBA,AGTA,AENA,AENA,AT2BA,AWjCA,ADGA;AXkCA,AKfA,AFMA,AGTA,AENA,AENA,AT2BA,AWjCA,ADGA;AXkCA,AKfA,AFMA,AGTA,AENA,AENA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AENA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AENA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AKfA,AFMA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AJYA,AT2BA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AGTA,AENA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AKfA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AKfA,AMlBA,AbuCA,AWjCA,ACHA,AFMA;AXkCA,AGTA,AKfA,AMlBA,AbuCA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AKfA,APqBA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AFMA,AYpCA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA,AFMA;AXkCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA,AU9BA;AbwCA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\nconst {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow,\n} = require('./rules/grid');\n\n// rules\nconst animation = require('./rules/animation');\nconst border = require('./rules/border');\nconst boxShadow = require('./rules/boxShadow');\nconst flexFlow = require('./rules/flexFlow');\nconst transition = require('./rules/transition');\nconst listStyle = require('./rules/listStyle');\nconst column = require('./rules/columns');\nconst vendorUnprefixed = require('./lib/vendorUnprefixed.js');\n\n/** @type {[string, (parsed: valueParser.ParsedValue) => string][]} */\nconst borderRules = [\n  ['border', border],\n  ['border-block', border],\n  ['border-inline', border],\n  ['border-block-end', border],\n  ['border-block-start', border],\n  ['border-inline-end', border],\n  ['border-inline-start', border],\n  ['border-top', border],\n  ['border-right', border],\n  ['border-bottom', border],\n  ['border-left', border],\n];\n\n/** @type {[string, (parsed: valueParser.ParsedValue) => string | string[] | valueParser.ParsedValue][]} */\nconst grid = [\n  ['grid-auto-flow', normalizeGridAutoFlow],\n  ['grid-column-gap', normalizeGridColumnRowGap], // normal | <length-percentage>\n  ['grid-row-gap', normalizeGridColumnRowGap], // normal | <length-percentage>\n  ['grid-column', normalizeGridColumnRow], // <grid-line>+\n  ['grid-row', normalizeGridColumnRow], // <grid-line>+\n  ['grid-row-start', normalizeGridColumnRow], // <grid-line>\n  ['grid-row-end', normalizeGridColumnRow], // <grid-line>\n  ['grid-column-start', normalizeGridColumnRow], // <grid-line>\n  ['grid-column-end', normalizeGridColumnRow], // <grid-line>\n];\n\n/** @type {[string, (parsed: valueParser.ParsedValue) => string | valueParser.ParsedValue][]} */\nconst columnRules = [\n  ['column-rule', border],\n  ['columns', column],\n];\n\n/** @type {Map<string, ((parsed: valueParser.ParsedValue) => string | string[] | valueParser.ParsedValue)>} */\nconst rules = new Map([\n  ['animation', animation],\n  ['outline', border],\n  ['box-shadow', boxShadow],\n  ['flex-flow', flexFlow],\n  ['list-style', listStyle],\n  ['transition', transition],\n  ...borderRules,\n  ...grid,\n  ...columnRules,\n]);\n\nconst variableFunctions = new Set(['var', 'env', 'constant']);\n\n/**\n * @param {valueParser.Node} node\n * @return {boolean}\n */\nfunction isVariableFunctionNode(node) {\n  if (node.type !== 'function') {\n    return false;\n  }\n\n  return variableFunctions.has(node.value.toLowerCase());\n}\n\n/**\n * @param {valueParser.ParsedValue} parsed\n * @return {boolean}\n */\nfunction shouldAbort(parsed) {\n  let abort = false;\n\n  parsed.walk((node) => {\n    if (\n      node.type === 'comment' ||\n      isVariableFunctionNode(node) ||\n      (node.type === 'word' && node.value.includes(`___CSS_LOADER_IMPORT___`))\n    ) {\n      abort = true;\n\n      return false;\n    }\n  });\n\n  return abort;\n}\n\n/**\n * @param {import('postcss').Declaration} decl\n * @return {string}\n */\nfunction getValue(decl) {\n  let { value, raws } = decl;\n\n  if (raws && raws.value && raws.value.raw) {\n    value = raws.value.raw;\n  }\n\n  return value;\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-ordered-values',\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls((decl) => {\n            const lowerCasedProp = decl.prop.toLowerCase();\n            const normalizedProp = vendorUnprefixed(lowerCasedProp);\n            const processor = rules.get(normalizedProp);\n\n            if (!processor) {\n              return;\n            }\n\n            const value = getValue(decl);\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n\n              return;\n            }\n\n            const parsed = valueParser(value);\n\n            if (parsed.nodes.length < 2 || shouldAbort(parsed)) {\n              cache.set(value, value);\n\n              return;\n            }\n\n            const result = processor(parsed);\n\n            decl.value = result.toString();\n            cache.set(value, result.toString());\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n","\nconst joinGridValue = require('../lib/joinGridValue');\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridAutoFlow\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\nconst normalizeGridAutoFlow = (gridAutoFlow) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridAutoFlow.walk((node) => {\n    if (node.value === 'dense') {\n      shouldNormalize = true;\n      newValue.back = node.value;\n    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      shouldNormalize = false;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridAutoFlow;\n};\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridGap\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\nconst normalizeGridColumnRowGap = (gridGap) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridGap.walk((node) => {\n    // console.log(node);\n    if (node.value === 'normal') {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      newValue.back = `${newValue.back} ${node.value}`;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridGap;\n};\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} grid\n * @return {string | string[]}\n */\nconst normalizeGridColumnRow = (grid) => {\n  // cant do normalization here using node, so copy it as a string\n  let gridValue = grid.toString().split('/'); // node -> string value, split ->  \" 2 / 3 span \" ->  [' 2','3 span ']\n  if (gridValue.length > 1) {\n    return joinGridValue(\n      gridValue.map((gridLine) => {\n        let normalizeValue = {\n          front: '',\n          back: '',\n        };\n        gridLine = gridLine.trim(); // '3 span ' -> '3 span'\n        gridLine.split(' ').forEach((node) => {\n          // ['3','span']\n          if (node === 'span') {\n            normalizeValue.front = node; // span _\n          } else {\n            normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3\n          }\n        });\n        return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3\n      })\n      // returns \"2 / span 3\"\n    );\n  }\n  // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end\n  return gridValue.map((gridLine) => {\n    let normalizeValue = {\n      front: '',\n      back: '',\n    };\n    gridLine = gridLine.trim();\n    gridLine.split(' ').forEach((node) => {\n      if (node === 'span') {\n        normalizeValue.front = node;\n      } else {\n        normalizeValue.back = `${normalizeValue.back} ${node}`;\n      }\n    });\n    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;\n  });\n};\n\nmodule.exports = {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow,\n};\n","\n/**\n * @param {string[]} grid\n * @return {string}\n */\nmodule.exports = function joinGridVal(grid) {\n  return grid.join(' / ').trim();\n};\n","\nconst { unit } = require('postcss-value-parser');\nconst { getArguments } = require('cssnano-utils');\nconst addSpace = require('../lib/addSpace');\nconst getValue = require('../lib/getValue');\n\n// animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>\nconst functions = new Set(['steps', 'cubic-bezier', 'frames']);\nconst keywords = new Set([\n  'ease',\n  'ease-in',\n  'ease-in-out',\n  'ease-out',\n  'linear',\n  'step-end',\n  'step-start',\n]);\n\nconst directions = new Set([\n  'normal',\n  'reverse',\n  'alternate',\n  'alternate-reverse',\n]);\nconst fillModes = new Set(['none', 'forwards', 'backwards', 'both']);\nconst playStates = new Set(['running', 'paused']);\nconst timeUnits = new Set(['ms', 's']);\n\n/**\n * @param {string} value\n * @param {string} type\n * @return {boolean}\n */\nconst isTimingFunction = (value, type) => {\n  return (type === 'function' && functions.has(value)) || keywords.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isDirection = (value) => {\n  return directions.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isFillMode = (value) => {\n  return fillModes.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isPlayState = (value) => {\n  return playStates.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isTime = (value) => {\n  const quantity = unit(value);\n\n  return quantity && timeUnits.has(quantity.unit);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isIterationCount = (value) => {\n  const quantity = unit(value);\n\n  return value === 'infinite' || (quantity && !quantity.unit);\n};\n\nconst stateConditions = [\n  { property: 'duration', delegate: isTime },\n  { property: 'timingFunction', delegate: isTimingFunction },\n  { property: 'delay', delegate: isTime },\n  { property: 'iterationCount', delegate: isIterationCount },\n  { property: 'direction', delegate: isDirection },\n  { property: 'fillMode', delegate: isFillMode },\n  { property: 'playState', delegate: isPlayState },\n];\n/**\n * @param {import('postcss-value-parser').Node[][]} args\n * @return {import('postcss-value-parser').Node[][]}\n */\nfunction normalize(args) {\n  const list = [];\n\n  for (const arg of args) {\n    /** @type {Record<string, import('postcss-value-parser').Node[]>} */\n    const state = {\n      name: [],\n      duration: [],\n      timingFunction: [],\n      delay: [],\n      iterationCount: [],\n      direction: [],\n      fillMode: [],\n      playState: [],\n    };\n\n    arg.forEach((node) => {\n      let { type, value } = node;\n\n      if (type === 'space') {\n        return;\n      }\n\n      value = value.toLowerCase();\n\n      const hasMatch = stateConditions.some(({ property, delegate }) => {\n        if (delegate(value, type) && !state[property].length) {\n          state[property] = [node, addSpace()];\n          return true;\n        }\n      });\n\n      if (!hasMatch) {\n        state.name = [...state.name, node, addSpace()];\n      }\n    });\n\n    list.push([\n      ...state.name,\n      ...state.duration,\n      ...state.timingFunction,\n      ...state.delay,\n      ...state.iterationCount,\n      ...state.direction,\n      ...state.fillMode,\n      ...state.playState,\n    ]);\n  }\n  return list;\n}\n/**\n * @param {import('postcss-value-parser').ParsedValue} parsed\n * @return {string}\n */\nmodule.exports = function normalizeAnimation(parsed) {\n  const values = normalize(getArguments(parsed));\n\n  return getValue(values);\n};\n","\n/** @return {import('postcss-value-parser').SpaceNode} */\nmodule.exports = function addSpace() {\n  return /** @type import('postcss-value-parser').SpaceNode */ ({\n    type: 'space',\n    value: ' ',\n  });\n};\n","\nconst { stringify } = require('postcss-value-parser');\n\n/**\n * @param {import('postcss-value-parser').Node[][]} values\n * @return {string}\n */\nmodule.exports = function getValue(values) {\n  return stringify(flatten(values));\n};\n/**\n * @param {import('postcss-value-parser').Node[][]} values\n * @return {import('postcss-value-parser').Node[]}\n */\nfunction flatten(values) {\n  /** @type {import('postcss-value-parser').Node[]} */\n  const nodes = [];\n  for (const [index, arg] of values.entries()) {\n    arg.forEach((val, idx) => {\n      if (\n        idx === arg.length - 1 &&\n        index === values.length - 1 &&\n        val.type === 'space'\n      ) {\n        return;\n      }\n      nodes.push(val);\n    });\n\n    if (index !== values.length - 1) {\n      nodes[nodes.length - 1].type = 'div';\n      nodes[nodes.length - 1].value = ',';\n    }\n  }\n  return nodes;\n}\n","\nconst { unit, stringify } = require('postcss-value-parser');\nconst mathFunctions = require('../lib/mathfunctions.js');\n\n// border: <line-width> || <line-style> || <color>\n// outline: <outline-color> || <outline-style> || <outline-width>\n\nconst borderWidths = new Set(['thin', 'medium', 'thick']);\n\nconst borderStyles = new Set([\n  'none',\n  'auto', // only in outline-style\n  'hidden',\n  'dotted',\n  'dashed',\n  'solid',\n  'double',\n  'groove',\n  'ridge',\n  'inset',\n  'outset',\n]);\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} border\n * @return {string}\n */\nmodule.exports = function normalizeBorder(border) {\n  const order = { width: '', style: '', color: '' };\n\n  border.walk((node) => {\n    const { type, value } = node;\n    if (type === 'word') {\n      if (borderStyles.has(value.toLowerCase())) {\n        order.style = value;\n        return false;\n      }\n      if (borderWidths.has(value.toLowerCase()) || unit(value.toLowerCase())) {\n        if (order.width !== '') {\n          order.width = `${order.width} ${value}`;\n          return false;\n        }\n        order.width = value;\n        return false;\n      }\n      order.color = value;\n      return false;\n    }\n    if (type === 'function') {\n      if (mathFunctions.has(value.toLowerCase())) {\n        order.width = stringify(node);\n      } else {\n        order.color = stringify(node);\n      }\n      return false;\n    }\n  });\n\n  return `${order.width} ${order.style} ${order.color}`.trim();\n};\n","\n// All of the curently implemented math functions\nmodule.exports = new Set(['calc', 'clamp', 'max', 'min']);\n","\nconst { unit } = require('postcss-value-parser');\nconst { getArguments } = require('cssnano-utils');\nconst addSpace = require('../lib/addSpace');\nconst getValue = require('../lib/getValue');\nconst mathFunctions = require('../lib/mathfunctions.js');\nconst vendorUnprefixed = require('../lib/vendorUnprefixed.js');\n\n// box-shadow: inset? && <length>{2,4} && <color>?\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} parsed\n * @return {string}\n */\nmodule.exports = function normalizeBoxShadow(parsed) {\n  let args = getArguments(parsed);\n\n  const normalized = normalize(args);\n\n  if (normalized === false) {\n    return parsed.toString();\n  }\n\n  return getValue(normalized);\n};\n/**\n * @param {import('postcss-value-parser').Node[][]} args\n * @return {false | import('postcss-value-parser').Node[][]}\n */\nfunction normalize(args) {\n  const list = [];\n  let abort = false;\n  for (const arg of args) {\n    /** @type {import('postcss-value-parser').Node[]} */\n    let val = [];\n    /** @type {Record<'inset'|'color', import('postcss-value-parser').Node[]>} */\n    let state = {\n      inset: [],\n      color: [],\n    };\n\n    arg.forEach((node) => {\n      const { type, value } = node;\n\n      if (\n        type === 'function' &&\n        mathFunctions.has(vendorUnprefixed(value.toLowerCase()))\n      ) {\n        abort = true;\n        return;\n      }\n\n      if (type === 'space') {\n        return;\n      }\n\n      if (unit(value)) {\n        val = [...val, node, addSpace()];\n      } else if (value.toLowerCase() === 'inset') {\n        state.inset = [...state.inset, node, addSpace()];\n      } else {\n        state.color = [...state.color, node, addSpace()];\n      }\n    });\n\n    if (abort) {\n      return false;\n    }\n\n    list.push([...state.inset, ...val, ...state.color]);\n  }\n  return list;\n}\n","\n/**\n * @param {string} prop\n * @return {string}\n */\nfunction vendorUnprefixed(prop) {\n  return prop.replace(/^-\\w+-/, '');\n}\n\nmodule.exports = vendorUnprefixed;\n","\n// flex-flow: <flex-direction> || <flex-wrap>\n\nconst flexDirection = new Set([\n  'row',\n  'row-reverse',\n  'column',\n  'column-reverse',\n]);\n\nconst flexWrap = new Set(['nowrap', 'wrap', 'wrap-reverse']);\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} flexFlow\n * @return {string}\n */\nmodule.exports = function normalizeFlexFlow(flexFlow) {\n  let order = {\n    direction: '',\n    wrap: '',\n  };\n\n  flexFlow.walk(({ value }) => {\n    if (flexDirection.has(value.toLowerCase())) {\n      order.direction = value;\n      return;\n    }\n\n    if (flexWrap.has(value.toLowerCase())) {\n      order.wrap = value;\n      return;\n    }\n  });\n\n  return `${order.direction} ${order.wrap}`.trim();\n};\n","\nconst { unit } = require('postcss-value-parser');\nconst { getArguments } = require('cssnano-utils');\nconst addSpace = require('../lib/addSpace');\nconst getValue = require('../lib/getValue');\n\n// transition: [ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>\n\nconst timingFunctions = new Set([\n  'ease',\n  'linear',\n  'ease-in',\n  'ease-out',\n  'ease-in-out',\n  'step-start',\n  'step-end',\n]);\n\n/**\n * @param {import('postcss-value-parser').Node[][]} args\n * @return {import('postcss-value-parser').Node[][]}\n */\nfunction normalize(args) {\n  const list = [];\n  for (const arg of args) {\n    /** @type {Record<string, import('postcss-value-parser').Node[]>} */\n    let state = {\n      timingFunction: [],\n      property: [],\n      time1: [],\n      time2: [],\n    };\n\n    arg.forEach((node) => {\n      const { type, value } = node;\n\n      if (type === 'space') {\n        return;\n      }\n\n      if (\n        type === 'function' &&\n        new Set(['steps', 'cubic-bezier']).has(value.toLowerCase())\n      ) {\n        state.timingFunction = [...state.timingFunction, node, addSpace()];\n      } else if (unit(value)) {\n        if (!state.time1.length) {\n          state.time1 = [...state.time1, node, addSpace()];\n        } else {\n          state.time2 = [...state.time2, node, addSpace()];\n        }\n      } else if (timingFunctions.has(value.toLowerCase())) {\n        state.timingFunction = [...state.timingFunction, node, addSpace()];\n      } else {\n        state.property = [...state.property, node, addSpace()];\n      }\n    });\n\n    list.push([\n      ...state.property,\n      ...state.time1,\n      ...state.timingFunction,\n      ...state.time2,\n    ]);\n  }\n  return list;\n}\n/**\n * @param {import('postcss-value-parser').ParsedValue} parsed\n * @return {string}\n */\nmodule.exports = function normalizeTransition(parsed) {\n  const values = normalize(getArguments(parsed));\n\n  return getValue(values);\n};\n","\nconst valueParser = require('postcss-value-parser');\nconst listStyleTypes = require('./listStyleTypes.json');\n\nconst definedTypes = new Set(listStyleTypes['list-style-type']);\n\nconst definedPosition = new Set(['inside', 'outside']);\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} listStyle\n * @return {string}\n */\nmodule.exports = function listStyleNormalizer(listStyle) {\n  const order = { type: '', position: '', image: '' };\n\n  listStyle.walk((decl) => {\n    if (decl.type === 'word') {\n      if (definedTypes.has(decl.value)) {\n        // its a type field\n        order.type = `${order.type} ${decl.value}`;\n      } else if (definedPosition.has(decl.value)) {\n        order.position = `${order.position} ${decl.value}`;\n      } else if (decl.value === 'none') {\n        if (\n          order.type\n            .split(' ')\n            .filter((e) => e !== '' && e !== ' ')\n            .includes('none')\n        ) {\n          order.image = `${order.image} ${decl.value}`;\n        } else {\n          order.type = `${order.type} ${decl.value}`;\n        }\n      } else {\n        order.type = `${order.type} ${decl.value}`;\n      }\n    }\n    if (decl.type === 'function') {\n      order.image = `${order.image} ${valueParser.stringify(decl)}`;\n    }\n  });\n\n  return `${order.type.trim()} ${order.position.trim()} ${order.image.trim()}`.trim();\n};\n","module.exports = {\n  \"list-style-type\": [\n    \"afar\",\n    \"amharic\",\n    \"amharic-abegede\",\n    \"arabic-indic\",\n    \"armenian\",\n    \"asterisks\",\n    \"bengali\",\n    \"binary\",\n    \"cambodian\",\n    \"circle\",\n    \"cjk-decimal\",\n    \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\",\n    \"cjk-ideographic\",\n    \"decimal\",\n    \"decimal-leading-zero\",\n    \"devanagari\",\n    \"disc\",\n    \"disclosure-closed\",\n    \"disclosure-open\",\n    \"ethiopic\",\n    \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\",\n    \"ethiopic-abegede-gez\",\n    \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\",\n    \"ethiopic-halehame\",\n    \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\",\n    \"ethiopic-halehame-am\",\n    \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\",\n    \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\",\n    \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\",\n    \"ethiopic-halehame-ti-et\",\n    \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\",\n    \"footnotes\",\n    \"georgian\",\n    \"gujarati\",\n    \"gurmukhi\",\n    \"hangul\",\n    \"hangul-consonant\",\n    \"hebrew\",\n    \"hiragana\",\n    \"hiragana-iroha\",\n    \"japanese-formal\",\n    \"japanese-informal\",\n    \"kannada\",\n    \"katakana\",\n    \"katakana-iroha\",\n    \"khmer\",\n    \"korean-hangul-formal\",\n    \"korean-hanja-formal\",\n    \"korean-hanja-informal\",\n    \"lao\",\n    \"lower-alpha\",\n    \"lower-armenian\",\n    \"lower-greek\",\n    \"lower-hexadecimal\",\n    \"lower-latin\",\n    \"lower-norwegian\",\n    \"lower-roman\",\n    \"malayalam\",\n    \"mongolian\",\n    \"myanmar\",\n    \"octal\",\n    \"oriya\",\n    \"oromo\",\n    \"persian\",\n    \"sidama\",\n    \"simp-chinese-formal\",\n    \"simp-chinese-informal\",\n    \"somali\",\n    \"square\",\n    \"string\",\n    \"symbols\",\n    \"tamil\",\n    \"telugu\",\n    \"thai\",\n    \"tibetan\",\n    \"tigre\",\n    \"tigrinya-er\",\n    \"tigrinya-er-abegede\",\n    \"tigrinya-et\",\n    \"tigrinya-et-abegede\",\n    \"trad-chinese-formal\",\n    \"trad-chinese-informal\",\n    \"upper-alpha\",\n    \"upper-armenian\",\n    \"upper-greek\",\n    \"upper-hexadecimal\",\n    \"upper-latin\",\n    \"upper-norwegian\",\n    \"upper-roman\",\n    \"urdu\"\n  ]\n}","\nconst { unit } = require('postcss-value-parser');\n\n/**\n * @param {string} value\n * @return {boolean}\n */\nfunction hasUnit(value) {\n  const parsedVal = unit(value);\n  return parsedVal && parsedVal.unit !== '';\n}\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} columns\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\nmodule.exports = (columns) => {\n  /** @type {string[]} */\n  const widths = [];\n  /** @type {string[]} */\n  const other = [];\n  columns.walk((node) => {\n    const { type, value } = node;\n    if (type === 'word') {\n      if (hasUnit(value)) {\n        widths.push(value);\n      } else {\n        other.push(value);\n      }\n    }\n  });\n\n  // only transform if declaration is not invalid or a single value\n  if (other.length === 1 && widths.length === 1) {\n    return `${widths[0].trimStart()} ${other[0].trimStart()}`;\n  }\n\n  return columns;\n};\n"]}