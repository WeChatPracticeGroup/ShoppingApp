{"version":3,"sources":["index.js","minimalVisitor.js","buildOptimizedSequenceExpression.js","smartVisitor.js","fsharpVisitor.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxPipelineOperator = _interopRequireDefault(require(\"@babel/plugin-syntax-pipeline-operator\"));\n\nvar _minimalVisitor = _interopRequireDefault(require(\"./minimalVisitor\"));\n\nvar _smartVisitor = _interopRequireDefault(require(\"./smartVisitor\"));\n\nvar _fsharpVisitor = _interopRequireDefault(require(\"./fsharpVisitor\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst visitorsPerProposal = {\n  minimal: _minimalVisitor.default,\n  smart: _smartVisitor.default,\n  fsharp: _fsharpVisitor.default\n};\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  return {\n    name: \"proposal-pipeline-operator\",\n    inherits: _pluginSyntaxPipelineOperator.default,\n    visitor: visitorsPerProposal[options.proposal]\n  };\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _buildOptimizedSequenceExpression = _interopRequireDefault(require(\"./buildOptimizedSequenceExpression\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst minimalVisitor = {\n  BinaryExpression(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      operator,\n      left,\n      right\n    } = node;\n    if (operator !== \"|>\") return;\n    const placeholder = scope.generateUidIdentifierBasedOnNode(left);\n\n    const call = _core.types.callExpression(right, [_core.types.cloneNode(placeholder)]);\n\n    path.replaceWith((0, _buildOptimizedSequenceExpression.default)({\n      assign: _core.types.assignmentExpression(\"=\", _core.types.cloneNode(placeholder), left),\n      call,\n      path\n    }));\n  }\n\n};\nvar _default = minimalVisitor;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nconst buildOptimizedSequenceExpression = ({\n  assign,\n  call,\n  path\n}) => {\n  const {\n    left: placeholderNode,\n    right: pipelineLeft\n  } = assign;\n  const {\n    callee: calledExpression\n  } = call;\n  let optimizeArrow = _core.types.isArrowFunctionExpression(calledExpression) && _core.types.isExpression(calledExpression.body) && !calledExpression.async && !calledExpression.generator;\n  let param;\n\n  if (optimizeArrow) {\n    const {\n      params\n    } = calledExpression;\n\n    if (params.length === 1 && _core.types.isIdentifier(params[0])) {\n      param = params[0];\n    } else if (params.length > 0) {\n      optimizeArrow = false;\n    }\n  } else if (_core.types.isIdentifier(calledExpression, {\n    name: \"eval\"\n  })) {\n    const evalSequence = _core.types.sequenceExpression([_core.types.numericLiteral(0), calledExpression]);\n\n    call.callee = evalSequence;\n    path.scope.push({\n      id: _core.types.cloneNode(placeholderNode)\n    });\n    return _core.types.sequenceExpression([assign, call]);\n  }\n\n  if (optimizeArrow && !param) {\n    return _core.types.sequenceExpression([pipelineLeft, calledExpression.body]);\n  }\n\n  path.scope.push({\n    id: _core.types.cloneNode(placeholderNode)\n  });\n\n  if (param) {\n    path.get(\"right\").scope.rename(param.name, placeholderNode.name);\n    return _core.types.sequenceExpression([assign, calledExpression.body]);\n  }\n\n  return _core.types.sequenceExpression([assign, call]);\n};\n\nvar _default = buildOptimizedSequenceExpression;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nconst updateTopicReferenceVisitor = {\n  PipelinePrimaryTopicReference(path) {\n    path.replaceWith(_core.types.cloneNode(this.topicId));\n  },\n\n  PipelineTopicExpression(path) {\n    path.skip();\n  }\n\n};\nconst smartVisitor = {\n  BinaryExpression(path) {\n    const {\n      scope\n    } = path;\n    const {\n      node\n    } = path;\n    const {\n      operator,\n      left,\n      right\n    } = node;\n    if (operator !== \"|>\") return;\n    const placeholder = scope.generateUidIdentifierBasedOnNode(left);\n    scope.push({\n      id: placeholder\n    });\n    let call;\n\n    if (_core.types.isPipelineTopicExpression(right)) {\n      path.get(\"right\").traverse(updateTopicReferenceVisitor, {\n        topicId: placeholder\n      });\n      call = right.expression;\n    } else {\n      let callee = right.callee;\n\n      if (_core.types.isIdentifier(callee, {\n        name: \"eval\"\n      })) {\n        callee = _core.types.sequenceExpression([_core.types.numericLiteral(0), callee]);\n      }\n\n      call = _core.types.callExpression(callee, [_core.types.cloneNode(placeholder)]);\n    }\n\n    path.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(placeholder), left), call]));\n  }\n\n};\nvar _default = smartVisitor;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _buildOptimizedSequenceExpression = _interopRequireDefault(require(\"./buildOptimizedSequenceExpression\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst fsharpVisitor = {\n  BinaryExpression(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      operator,\n      left,\n      right\n    } = node;\n    if (operator !== \"|>\") return;\n    const placeholder = scope.generateUidIdentifierBasedOnNode(left);\n    const call = right.type === \"AwaitExpression\" ? _core.types.awaitExpression(_core.types.cloneNode(placeholder)) : _core.types.callExpression(right, [_core.types.cloneNode(placeholder)]);\n    const sequence = (0, _buildOptimizedSequenceExpression.default)({\n      assign: _core.types.assignmentExpression(\"=\", _core.types.cloneNode(placeholder), left),\n      call,\n      path\n    });\n    path.replaceWith(sequence);\n  }\n\n};\nvar _default = fsharpVisitor;\nexports.default = _default;"]}