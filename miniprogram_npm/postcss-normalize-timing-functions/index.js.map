{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst valueParser = require('postcss-value-parser');\n\n/** @type {(node: valueParser.Node) => number} */\nconst getValue = (node) => parseFloat(node.value);\n\n/* Works because toString() normalizes the formatting,\n   so comparing the string forms behaves the same as number equality*/\nconst conversions = new Map([\n  [[0.25, 0.1, 0.25, 1].toString(), 'ease'],\n  [[0, 0, 1, 1].toString(), 'linear'],\n  [[0.42, 0, 1, 1].toString(), 'ease-in'],\n  [[0, 0, 0.58, 1].toString(), 'ease-out'],\n  [[0.42, 0, 0.58, 1].toString(), 'ease-in-out'],\n]);\n/**\n * @param {valueParser.Node} node\n * @return {void | false}\n */\nfunction reduce(node) {\n  if (node.type !== 'function') {\n    return false;\n  }\n\n  if (!node.value) {\n    return;\n  }\n\n  const lowerCasedValue = node.value.toLowerCase();\n\n  if (lowerCasedValue === 'steps') {\n    // Don't bother checking the step-end case as it has the same length\n    // as steps(1)\n    if (\n      node.nodes[0].type === 'word' &&\n      getValue(node.nodes[0]) === 1 &&\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'start' ||\n        node.nodes[2].value.toLowerCase() === 'jump-start')\n    ) {\n      /** @type string */ (node.type) = 'word';\n      node.value = 'step-start';\n\n      delete (/** @type Partial<valueParser.FunctionNode> */ (node).nodes);\n\n      return;\n    }\n\n    if (\n      node.nodes[0].type === 'word' &&\n      getValue(node.nodes[0]) === 1 &&\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'end' ||\n        node.nodes[2].value.toLowerCase() === 'jump-end')\n    ) {\n      /** @type string */ (node.type) = 'word';\n      node.value = 'step-end';\n\n      delete (/** @type Partial<valueParser.FunctionNode> */ (node).nodes);\n\n      return;\n    }\n\n    // The end case is actually the browser default, so it isn't required.\n    if (\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'end' ||\n        node.nodes[2].value.toLowerCase() === 'jump-end')\n    ) {\n      node.nodes = [node.nodes[0]];\n\n      return;\n    }\n\n    return false;\n  }\n\n  if (lowerCasedValue === 'cubic-bezier') {\n    const values = node.nodes\n      .filter((list, index) => {\n        return index % 2 === 0;\n      })\n      .map(getValue);\n\n    if (values.length !== 4) {\n      return;\n    }\n\n    const match = conversions.get(values.toString());\n\n    if (match) {\n      /** @type string */ (node.type) = 'word';\n      node.value = match;\n\n      delete (/** @type Partial<valueParser.FunctionNode> */ (node).nodes);\n\n      return;\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @return {string}\n */\nfunction transform(value) {\n  return valueParser(value).walk(reduce).toString();\n}\n\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-normalize-timing-functions',\n\n    OnceExit(css) {\n      const cache = new Map();\n\n      css.walkDecls(\n        /^(-\\w+-)?(animation|transition)(-timing-function)?$/i,\n        (decl) => {\n          const value = decl.value;\n\n          if (cache.has(value)) {\n            decl.value = cache.get(value);\n\n            return;\n          }\n\n          const result = transform(value);\n\n          decl.value = result;\n          cache.set(value, result);\n        }\n      );\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]}